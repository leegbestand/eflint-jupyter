diff --git a/README.md b/README.md
index 8e69363..b488ea4 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
-## eFLINT 
+# eFLINT
 
 Haskell implementation of the eFLINT language, providing an interpreter for exploring normative behaviour, testing normative models and interacting with a normative model for runtime verification and simulation.
 
-### Installation
+## Installation
 
 Requires GHC, the glorius Glasgow Haskell Compiler, and Cabal, Haskell's old skool package manager. On unix:
 
@@ -16,7 +16,7 @@ Then in your local copy of this directory:
 ```
 cabal v1-configure
 cabal v1-build
-cabal v1-install 
+cabal v1-install
 ```
 
 When using a very old or a very new version of cabal, use `cabal build` and `cabal build` and `cabal install` instead.
@@ -26,7 +26,7 @@ Upon successful installation:
 * the executable is found at `dist/build/eflint-server/eflint-server`
 * the script `examples/run_tests.sh` should run successfully and produce no output.
 
-### Executable `eflint-repl`
+## Executable `eflint-repl`
 
 Run eFLINT as a REPL.
 
@@ -35,54 +35,53 @@ Run eFLINT as a REPL.
 The scenario in `FILE` is ignored (although this may change in the future).
 Once loaded, type `:help` to see the available commands.
 
-### Executable `eflint-server`
+## Executable `eflint-server`
 
-#### Usage
+### Usage
 
 `eflint-server <FILE.eflint> <PORT> <OPTIONS*>`
 
 with `<OPTIONS>` either:
- 
+
 * `--debug` (increases verbosity of the server)
 
-#### Protocol
+### Protocol
 
-The `eflint-server` listens to commands on the given `<PORT>`. 
-Any input that does not follow the format discussed below will be rejected by the server, responding with
-
-```
-{
-    response  : "invalid command"
-}    
-``` 
+The `eflint-server` listens to commands on the given `<PORT>`.
 
 If a command is executed successfully this might result in the server updating its internal state.
 If this is the case then the response will contain a field `newstate : <INTEGER>`.
 
-Valid commands have one of the following forms.
-
-**Status report**
-
-Check the status of the server.
+---
+#### Responses
+Responses from the protocol can have one of the following forms.
 
+**Status response**
 ```
 {
-    command : "status"
-}
-```
+    response                 : "success",
+    old-state                : <INTEGER>,
+    new-state                : <INTEGER>,
 
-If the server is ready and waiting for further commands, it will respond with information about its current state in the form:
+    source_contents          : <VALUE*>,
+    target_contents          : <VALUE*>,
+    created_facts            : <VALUE*>,
+    terminated_facts         : <VALUE*>,
 
-```
-{
-    response   : "success",
-    new-state  : <INTEGER>,
-    violations : <VIOLATION*>
+    violations               : <VIOLATION*>,
+    output-events            : <EVENT*>
+    errors                   : <ERROR*>
+    query-results            : <BOOL*>
+
+    new-duties               : <VALUE*>,
+    new-enabled-transitions  : <VALUE*>,
+    new-disabled-transitions : <VALUE*>,
+    all-duties               : <VALUE*>,
+    all-enabled-transitions  : <VALUE*>,
+    all-disabled-transitions : <VALUE*>,
 }
 ```
-
-Where <VIOLATION*> is an array of elements of the form:
-
+Where `<VIOLATION*>` is an array of elements of the form:
 ```
 {
     violation : "trigger",
@@ -97,206 +96,269 @@ Where <VIOLATION*> is an array of elements of the form:
     invariant : <STRING>
 }
 ```
-
-**Killing the server**
-
+A `<VALUE>` is either an `<ATOM>` of the form
 ```
 {
-    command : "kill"
+    tagged-type : <STRING>,
+    fact-type   : <STRING>,
+    value       : <STRING>|<INTEGER>,
+    textual     : <STRING>
 }
 ```
 
-The server will gracefully terminate after responding with the message:
+or a `<COMPOSITE>` of the form
 
 ```
 {
-    response : "bye world.."
+    tagged-type : <STRING>,
+    fact-type   : <STRING>,
+    value       : <VALUE*>
+    textual     : <STRING>
+    
 }
 ```
+and `<VALUE*>` is an array of values.
 
-**Actions & Events**
-
-An action request is in one of the following forms.
-
+**Facts response**
 ```
 {
-    command     : "action",
-    act-type    : <STRING>,
-    actor       : <STRING>|<VALUE>,
-    recipient   : <STRING>|<VALUE>,
-    objects     : <(STRING|VALUE)*>,
-    force       : "true"|"false" //default is false
-}
-{
-    command     : "action|event",
-    value       : <VALUE>,
-    force       : "true"|"false" //default is false
+    values : <VALUE*>
 }
 ```
-
-A `<VALUE>` is either an `<ATOM>` of the form
-
+**Path response**
 ```
 {
-    fact-type : <STRING>,
-    value     : <STRING>|<INTEGER>
+    edges : <EDGE*>
 }
 ```
-
-or a `<COMPOSITE>` of the form
-
+Where `<EDGE*>` is an array of elements of the form:
 ```
 {
-    fact-type : <STRING>,
-    value     : <VALUE*>
-}
-```
-and `<VALUE*>` is an array of values.
+    phrase                   : <STRING>,
+    source_id                : <INTEGER>,
+    target_id                : <INTEGER>,
 
-The response to an action-command is an object of one of the following forms.
+    source_contents          : <VALUE*>,
+    target_contents          : <VALUE*>,
+    created_facts            : <VALUE*>,
+    terminated_facts         : <VALUE*>,
 
-```
-{
-    response                 : "success",
-    new-state                : <INTEGER>,
     violations               : <VIOLATION*>,
     output-events            : <EVENT*>
     errors                   : <ERROR*>
     query-results            : <BOOL*>
+
     new-duties               : <VALUE*>,
+    new-enabled-transitions  : <VALUE*>,
+    new-disabled-transitions : <VALUE*>,
     all-duties               : <VALUE*>,
     all-enabled-transitions  : <VALUE*>,
     all-disabled-transitions : <VALUE*>,
 }
+```
+**Head/Leaf nodes response**
+```
+{
+    state_id             : <INTEGER>,
+    state_contents       : <VALUE*>,
+    duties               : <VALUE*>,
+    enabled-transitions  : <VALUE*>,
+    disabled-transitions : <VALUE*>,
+}
+```
+**Exported graph response**
+```
 {
-    response : "invalid input",
-    error    : <STRING>
+    current : <INTEGER>
+    nodes   : <GRAPH_NODES*>,
+    EDGES   : <GRAPH_EDGES*>
 }
 ```
+Where `<GRAPH_NODES*>` and `<GRAPH_EDGES*>` are JSON objects of the nodes and edges in the current graph.
+
+**Loaded graph response**
+```
+{
+    response  : "success"
+}
+```
+**Killed response**
+```
+{
+    response  : "bye world..."
+}
+```
+**Invalid revert response**
+```
+{
+    response   : "invalid state"
+}
+```
+**Invalid command response**
+```
+{
+    response   : "invalid command"
+}
+```
+**Invalid input response**
+
+Any input that does not follow the format discussed in the **Commands** section will be rejected by the server, responding with
+```
+{
+    response  : "invalid input"
+}
+```
+**Field description (make one for every response or make this universal?)**
 
 | field | meaning |
 | ------ | ------ |
+| old-state | the number identifying the previous state the server was in |
 | new-state | the number identifying the state the server is currently in |
+| source_contents | the list of `<VALUE>` that exist in the previous state|
+| target_contents | the list of `<VALUE>` that exist in the designated/next state|
+| created_facts | the list of `<VALUE>` that exist in the designated/next state but not in the previous state|
+| terminated_facts | the list of `<VALUE>` that exist in the previous state but not in the designated/next state|
+||
 | violations | the duty violations, invariant violations, or non-compliant/disabled actions and events that were caused by the command that receives this response |
+| output-events | the list of output events (executed-transition) TODO|
+| errors | the list of errors (non-deterministic transition/disabled transition/compilation error) TODO|
+| query-results | the list of query results (True/False) TODO|
+||
 | new-duties | the new duties brought into existence by the command that receives this response |
+| new-enabled-transitions | the actions and events that can be triggered and will not cause a violation which were disabled in the previous state  |
+| new-disabled-actions | the actions and events that cannot be triggered or cause a violation when triggered which were enabled in the previous state |
 | all-duties | the duties present in the current state |
-| all-options | the values that of the current state may give rise to a transition: enabled actions, disabled actions (when forced) and events |
-| all-enabled-transitions | all actions and events that can be triggered and will not cause a violation  | 
-| new-enabled-transitions | the actions and events that can be triggered and will not cause a violation which were disabled in the previous state  | 
-| all-disabled-actions | all actions and events that cannot be triggered or cause a violation when triggered | 
-| new-disabled-actions | the actions and events that cannot be triggered or cause a violation when triggered which were enabled in the previous state | 
-
+| all-enabled-transitions | all actions and events that can be triggered and will not cause a violation  |
+| all-disabled-actions | all actions and events that cannot be triggered or cause a violation when triggered |
+| old-state | the number identifying the previous state the server was in |
+| new-state | the number identifying the state the server is currently in |
+||
+| phrase | a string that was executed as a phrase to create the corresponding edge |
+| source_id | the number identifying the previous state of an edge |
+| target_id | the number identifying the next state of an edge |
 
-An invalid action may occur if the fields do not constitute a valid action according to the server's normative model (e.g. based on type-checking).
-The error contains a message indicating what went wrong (structure not specified).
+---
 
+#### Commands
+Valid commands have one of the following forms.
 
-***Creation and termination events***
+##### Status report
+The `eflint-server` can check the status of the server by retrieving the last edge to the current state of the server.
 
 ```
 {
-    command   : "create",
-    value     : <VALUE>
-}
-{
-    command   : "terminate",
-    value     : <VALUE>
+    command : "status"
 }
 ```
+If the server is ready and waiting for further commands, it will respond with information about its current state with a **Status response**
 
-An event either fails because the provided value is not a value in the normative model or succeeds, resulting in a new state:
-
+##### Killing the server
+The `eflint-server` can kill a server with the following form:
 ```
 {
-    response    : "success",
-    new-state   : <INTEGER>,
-    violations  : <VIOLATION*>
-}
-{
-    response  : "invalid input",
-    error     : <STRING>
+    command : "kill"
 }
 ```
+The server will gracefully terminate with a **Killed response**
 
-**Queries**
-
+##### Facts
+The `eflint-server` can return all the facts in the current state using the following form:
 ```
 {
-    command   : "test-present",
-    value     : <VALUE>
-}
-{
-    command   : "test-absent",
-    value     : <VALUE>
-}
-{
-    command   : "enabled",
-    value     : <VALUE>
+    command : "facts"
 }
 ```
-A query either fails because it is not present (or not absent), fails because the provided value is not a value in the normative model, or succeeds (remaining in the same state):
-
+A successful request will respond with a **Facts response**.
+##### Path
+The `eflint-server` can return all the edges between the current state and the root state. If an <INTEGER> is provided for the value in the request form, the `eflint-server` will return all the edges between the current state and state assocciated with the provided <INTEGER>. A history request is in one of the following forms:
 ```
 {
-    query-results  : ["true"|"false"]
+    command : "history",
+    value   : <INTEGER>
 }
 {
-    response  : "invalid input",
-    error     : <STRING>
+    command : "history"
 }
 ```
+A successful request will respond with a **Path response**.
 
-**Facts**
-
-Get all the facts in the current state.
+##### Leaf nodes/head nodes
+The `eflint-server` can return all the leaf nodes of the execution graph/server using the following form:
 ```
 {
-    command : "facts"
+    command : "trace-heads"
 }
 ```
-Response:
+A successful request will respond with a **Head/Leaf nodes response**.
+##### Executing phrases
+The `eflint-server` can send and execute arbitrary phrases to the server, in the textual format accepted by `eflint-repl` (see the relevant documentation in the section "Executable `eflint-repl`") using the following form:
 ```
 {
-    values : <VALUE*>
+    command : "phrase",
+    text    : <STRING>
 }
 ```
+The response can be that of a **status response**, **Invalid input response**, or **invalid command response**
 
-
-**Backtracking**
-
+##### Backtracking
 The `eflint-server` can backtrack to one of its previous states (configurations), triggered by a command of the form:
-
 ```
 {
     command   : "revert",
     value     : <INTEGER>
 }
 ```
+The provided `<INTEGER>` should be a positive number previously been sent as part of a response or be a negative number, in which case the server will revert to its initial state. A successful backtrack will respond with a **Status response** in the new state, or a **Invalid revert response** when it fails.
+##### Creation and termination events
+The `eflint-server` can create or terminate `<VALUE>` instances using the following forms:
+```
+{
+    command   : "create",
+    value     : <VALUE>
+}
+{
+    command   : "terminate",
+    value     : <VALUE>
+}
+```
 
-The provided `<INTEGER>` should be a positive number previously been sent as part of a response or be a negative number, in which case the server will revert to its initial state.
+An event either fails because the provided value is not a value in the normative model or succeeds, resulting in a new state. A successful creation or termination will respond with a **Status response**, or an **Invalid input response** when it fails.
 
-The response is of the form:
 
+##### Queries
+The `eflint-server` can query `<VALUE>` instances whether they are present, absent, or enabled  using the following forms:
 ```
 {
-    response   : "success",
-    new-state  : <INTEGER>,
-    violations : <VIOLATION*>
+    command   : "test-present",
+    value     : <VALUE>
 }
 {
-    response   : "invalid state"
+    command   : "test-absent",
+    value     : <VALUE>
+}
+{
+    command   : "enabled",
+    value     : <VALUE>
 }
 ```
 
-**Phrases**
-
-Send arbitrary phrases to the server, in the textual format accepted by `eflint-repl` (see the relevant documentation in the section "Executable `eflint-repl`").
+A query either fails because the provided value is not a value in the normative model, or succeeds because it is present or absent. A successful query will respond with a **Status response**, or an **Invalid input response** when it fails.
 
+##### Actions & Events
+The `eflint-server` can execute an action request in one of the following forms:
 ```
 {
-    command : "phrase", 
-    text    : <STRING>
+    command     : "action",
+    act-type    : <STRING>,
+    actor       : <STRING>|<VALUE>,
+    recipient   : <STRING>|<VALUE>,
+    objects     : <(STRING|VALUE)*>,
+    force       : "true"|"false" //default is false
+}
+{
+    command     : "action|event",
+    value       : <VALUE>,
+    force       : "true"|"false" //default is false
 }
 ```
-
-The response can be that of a (un)successful action/event, failed/successful query, or invalid command (see above)
+An invalid action may occur if the fields do not constitute a valid action according to the server's normative model (e.g. based on type-checking). The error contains a message indicating what went wrong (structure not specified). A successful action will respond with a **Status response**, or an **Invalid input response** when it fails.
diff --git a/flint-simulation.cabal b/flint-simulation.cabal
index f567112..7b0e58d 100644
--- a/flint-simulation.cabal
+++ b/flint-simulation.cabal
@@ -76,7 +76,7 @@ executable eflint-server
                       , text >= 1.2.4.0
                       , filepath >= 1.4.2
                       , directory >= 1.3.6
-                      , exploring-interpreters >= 0.3.1.0 
+                      , exploring-interpreters >= 0.4.0.0
                       , fgl >= 5.7 
                       , mtl >= 2.2 
   hs-source-dirs:      src
@@ -113,7 +113,7 @@ executable eflint-repl
                       , mtl >= 2.2 
                       , haskeline >= 0.8.1
                       , transformers >= 0.5.6
-                      , exploring-interpreters >= 0.3.1.0 
+                      , exploring-interpreters >= 0.4.0.0
   hs-source-dirs:      src
   default-language:    Haskell2010
   ghc-options:         -fwarn-incomplete-patterns -fwarn-unused-imports
@@ -144,10 +144,9 @@ library
                       , network >= 3.1
                       , filepath >= 1.4.2
                       , directory >= 1.3.6
-                      , exploring-interpreters >= 0.3.1.0 
+                      , exploring-interpreters >= 0.4.0.0 
                       , fgl >= 5.7 
                       , mtl >= 2.2 
   hs-source-dirs:      src
   default-language:    Haskell2010
   ghc-options:         -fwarn-incomplete-patterns -fwarn-unused-imports
-
diff --git a/src/Eval.hs b/src/Eval.hs
index bada4ee..da17f28 100644
--- a/src/Eval.hs
+++ b/src/Eval.hs
@@ -203,13 +203,6 @@ data TransInfo = TransInfo {
                 , trans_is_action   :: Bool
                 }
 
-
-syncTransInfos :: [TransInfo] -> (S.Set Tagged {- terminated -} 
-                                 ,S.Set Tagged {- created -}
-                                 ,Bool {- forced? -})
-syncTransInfos = foldr op (S.empty, S.empty, False)
-  where op (TransInfo _ ts cs _ f _) (ts',cs',f') = (ts `S.union` ts', cs `S.union` cs', f || f')
-
 instantiate_trans :: Bool {- force? -} -> Tagged -> M_Subs TransInfo
 instantiate_trans force te@(v,d) = do 
   is_present <- is_in_virtual_state te 
@@ -218,35 +211,26 @@ instantiate_trans force te@(v,d) = do
     True  -> get_kind d >>= \case 
       Fact _      -> empty
       Duty _      -> empty 
-      Act aspec   -> do_transition te True is_present force (conditions aspec) (effects aspec) (syncs aspec)
-      Event espec -> do_transition te False is_present force [] (event_effects espec) []
+      Act aspec   -> do_transition te True is_present force (conditions aspec) (effects aspec)
+      Event espec -> do_transition te False is_present force [] (event_effects espec)
                           
-  where do_transition te@(v,d) isAction isPresent force mcond effects ss = do 
+  where select_instances (es_t, es_c) eff = case eff of
+          CAll xs t -> foreach xs (whenTagged (eval t) return) >>= \tes ->
+                        return (es_t, S.fromList tes `S.union` es_c)
+          TAll xs t -> foreach xs (whenTaggedHolds (eval t) return) >>= \tes ->
+                        return (S.fromList tes `S.union` es_t, es_c)
+        do_transition te@(v,d) isAction isPresent force mcond effects = do 
           (dom, _) <- get_dom d
           let Products xs = dom
           let Product args = v
           modify_subs (`subsUnion` (M.fromList (zip xs args))) $ do
-            sync_infos <- mapM (eval_sync force) ss 
-            let (ss_ts,ss_cs,any_f) = syncTransInfos (concat sync_infos)
-            (es_t', es_c') <- foldM select_instances (S.empty, S.empty) effects
-            let es_t = es_t' `S.union` ss_ts -- unite with effects of sync'ed transitions
-                es_c = es_c' `S.union` ss_cs
+            (es_t, es_c) <- foldM select_instances (S.empty, S.empty) effects
             case mcond of 
-              []      -> return (TransInfo te es_t es_c Trigger (any_f || not isPresent) isAction)
+              []      -> return (TransInfo te es_t es_c Trigger (not isPresent) isAction)
               conds   -> (or <$> results (and <$> mapM (flip whenBool return . eval) conds)) >>= \case
                               False | force     -> return (TransInfo te es_t es_c Trigger True isAction)
                                     | otherwise -> empty
-                              True  -> return (TransInfo te es_t es_c Trigger (any_f || not isPresent) isAction)
-
-        select_instances (es_t, es_c) eff = case eff of
-          CAll xs t -> foreach xs (whenTagged (eval t) return) >>= \tes ->
-                        return (es_t, S.fromList tes `S.union` es_c)
-          TAll xs t -> foreach xs (whenTaggedHolds (eval t) return) >>= \tes ->
-                        return (S.fromList tes `S.union` es_t, es_c)
-        
-
-eval_sync :: Bool -> Sync -> M_Subs [TransInfo]
-eval_sync force (Sync xs t) = foreach xs (whenTagged (eval t) (instantiate_trans force))
+                              True  -> return (TransInfo te es_t es_c Trigger (not isPresent) isAction)
 
 mk_present_when :: Spec -> Term -> DomId -> Derivation
 mk_present_when spec t d = Dv (S.toList args) (When (App d (Right [])) t)
@@ -266,10 +250,8 @@ eval_precondition te@(v,d) aspec = do
   (dom, _) <- get_dom d
   let Products xs = dom
   let Product args = v
-  modify_subs (`subsUnion` (M.fromList (zip xs args))) 
-    (or <$> results (and <$> mapM (flip whenBool return . eval) (conditions aspec ++ sync_conds aspec)))
-  where sync_conds aspec = map toBoolExpr (syncs aspec)
-          where toBoolExpr (Sync vs t) = Forall vs (Enabled t) -- all sync actions need to be enabled
+  modify_subs (`subsUnion` (M.fromList (zip xs args)))
+    (or <$> results (and <$> mapM (flip whenBool return . eval) (conditions aspec)))
 
 get_kind :: DomId -> M_Subs Kind
 get_kind d = M_Subs $ \spec state subs -> return . (state,) $ maybe [] (:[]) (find_kind spec d) 
diff --git a/src/Interpreter.hs b/src/Interpreter.hs
index 551d0f9..f8fe0e6 100644
--- a/src/Interpreter.hs
+++ b/src/Interpreter.hs
@@ -1,4 +1,4 @@
-module Interpreter (Config(..), Program, interpreter, initialConfig, rest_disabled, rest_enabled
+module Interpreter (Config(..), Program, interpreter, initialConfig, rest_disabled, rest_enabled, get_transition, context2config
                    ,OutputWriter, Output(..), getOutput
                    ,errors, violations, ex_triggers, query_ress) where
 
@@ -18,7 +18,7 @@ type Program = Phrase
 data Config = Config {
         cfg_spec          :: Spec
       , cfg_state         :: State 
-      , rest_transitions  :: [(Tagged, Bool)] -- (label * enabled?) -- replaced
+      , rest_transitions  :: [Transition] -- (label * enabled?) -- replaced
       , rest_duties       :: [Tagged] -- replaced after ever step
       }
       deriving (Eq)
@@ -27,7 +27,7 @@ data Output = ErrorVal Error
             | OutputEvent OutputEvent
             | Violation Violation
             | QueryRes QueryRes -- whether query succeed or not
-            deriving (Eq)
+            deriving (Eq, Show, Read)
 
 interpreter :: Program -> Config -> OutputWriter (Maybe Config)
 interpreter p cfg = case compile_phrase p ctx of
@@ -53,8 +53,11 @@ config2context cfg = Context {
   , ctx_duties = []
   }
 
-rest_enabled = map fst . filter snd . rest_transitions
-rest_disabled = map fst . filter (not . snd) . rest_transitions
+rest_enabled = map fst . filter snd . map get_transition . rest_transitions
+rest_disabled = map fst . filter (not . snd) . map get_transition . rest_transitions
+
+get_transition :: Transition -> (Tagged, Bool)
+get_transition transition = (tagged transition, exist transition)
 
 ex_triggers :: [Output] -> [OutputEvent]
 ex_triggers = concatMap op 
@@ -186,13 +189,16 @@ find_duties spec state = foldl op ([], []) (M.assocs (contents state))
       True  -> (te:ds, DutyViolation te:vds)
       False -> (te:ds, vds) 
   
-find_transitions :: Spec -> State -> [(Tagged, Bool)]
-find_transitions spec state = concatMap op (trigger_decls spec)
+find_transitions :: Spec -> State -> [Transition]
+find_transitions spec state = map create_transition (concatMap op (trigger_decls spec))
  where op (d,_) = map check (snd $ runSubs' (every_possible_subs (no_decoration d)) spec state emptySubs)
         where check te = case runSubs' (is_enabled te) spec state emptySubs of
                           (_,[b]) -> (te,b)
                           _       -> error "assert find_transitions"
 
+create_transition :: (Tagged, Bool) -> Transition
+create_transition (t, b) = Transition{tagged = t , exist = b}
+
 every_possible_subs :: Var -> M_Subs Tagged
 every_possible_subs x = do
     spec <- get_spec
diff --git a/src/NewExplorer.hs b/src/NewExplorer.hs
index 3cf59ef..8c0bded 100644
--- a/src/NewExplorer.hs
+++ b/src/NewExplorer.hs
@@ -1,9 +1,9 @@
 module NewExplorer where
 
-import Spec (Spec, Phrase(PSkip,PFrames) )
+import Spec (Spec, Phrase(PSkip) )
 import State (State)
 import qualified Language.Explorer.Pure as EI
-import Interpreter (Program, Config(..), interpreter, initialConfig, Output, getOutput)
+import Interpreter (Program, Config, interpreter, initialConfig, Output, getOutput)
 import Print()
 
 import Data.Tree (drawTree)
@@ -15,33 +15,62 @@ data Instruction = Execute [Program]
                  | Display Ref  -- `last' edge leading to given ref
                  | DisplayFull Ref -- full `history', see `Path' below, for given ref
                  | ExplorationHeads -- nodes in the execution graph without outgoing edges
+                 | CreateExportExploration -- create export data to recreate execution graph
+                 | LoadExportExploration ExecutionGraph -- load execution graph
 data Response    = ResultTrans Explorer [Output] (Config, Ref) (Config, Ref)
                  | Path Path
                  | Nodes [Node]
                  | InvalidRevert
+                 | ExportExploration ExecutionGraph
+                 | LoadExploration Explorer
 
 type Ref = Int -- state identifier
 type Path = [(Node, (Program, [Output]), Node)] 
 type Node = (Ref, Config)
 
+data N = N {
+           ref :: Ref
+         , config :: Config
+         }  
+         deriving (Eq)
+
+data Edge = Edge {
+            source :: Ref
+          , target :: Ref
+          , po     :: PO
+          }  
+          deriving (Eq)
+
+data PO = PO {
+          program :: Program
+        , output :: [Output]
+        }  
+        deriving (Eq)
+
+data ExecutionGraph = ExecutionGraph {
+                      current :: Ref
+                    , nodes   :: [N]
+                    , edges   :: [Edge]
+                    }
+
+-- type ExecutionGraph = (Ref, [(Ref, Config)], [(Ref, Ref, (Program, [Output]))])
+-- type ExecutionGraph = (Ref, [N], [Edge])
+
 showTree :: Explorer -> String
 showTree = drawTree . fmap (("#"++) . show . fst) . EI.toTree
 
 get_last_edge :: Explorer -> Ref -> ((Ref, Config), (Program, [Output]), (Ref, Config))
 get_last_edge exp cr = case reverse (EI.getPathFromTo exp 1 cr) of
-  (edge:_) -> edge 
-  _ -> maybe (error ("ASSERT: get_last_edge1")) (\cfg -> ((cr,cfg), (PSkip,[]), (cr,cfg))) (EI.deref exp cr) 
-        
-init_stack_explorer, init_tree_explorer, init_graph_explorer :: Maybe (Spec,State) -> Explorer
-init_stack_explorer Nothing = EI.mkExplorerStack defInterpreter initialConfig
-init_stack_explorer (Just (spec,state)) = 
- fst (EI.execute (PFrames spec []) $ EI.mkExplorerStack defInterpreter (initialConfig {cfg_state = state}))
-init_tree_explorer Nothing = EI.mkExplorerTree defInterpreter initialConfig
-init_tree_explorer (Just (spec,state)) = 
- fst (EI.execute (PFrames spec []) $ EI.mkExplorerTree defInterpreter (initialConfig {cfg_state = state}))
-init_graph_explorer Nothing = EI.mkExplorerGraph defInterpreter initialConfig
-init_graph_explorer (Just (spec,state)) = 
- fst (EI.execute (PFrames spec []) $ EI.mkExplorerGraph defInterpreter (initialConfig {cfg_state = state}))
+  (edge:_) -> edge
+  _ -> maybe (error ("ASSERT: get_last_edge1")) (\cfg -> ((cr,cfg), (PSkip,[]), (cr,cfg))) (EI.deref exp cr)
+
+init_stack_explorer, init_tree_explorer, init_graph_explorer :: Spec -> State -> Explorer
+init_stack_explorer spec state = 
+ EI.mkExplorerStack defInterpreter initialConfig -- TODO, how to treat JSON input and eFLINT-1.0 input?
+init_tree_explorer spec state = 
+ EI.mkExplorerTree defInterpreter initialConfig -- TODO, how to treat JSON input and eFLINT-1.0 input?
+init_graph_explorer spec state = 
+ EI.mkExplorerGraph defInterpreter initialConfig -- TODO, how to treat JSON input and eFLINT-1.0 input?
 
 defInterpreter p c = getOutput $ interpreter p c
 
@@ -58,5 +87,27 @@ run_ exp instr = case instr of
   Display id -> ResultTrans exp out (from, pr) (to, cr)
     where ((pr,from), (_,out), (cr, to)) = get_last_edge exp id
   DisplayFull id -> Path $ EI.getPathFromTo exp 1 id
-  ExplorationHeads -> Nodes $ EI.leaves exp 
+  ExplorationHeads -> Nodes $ EI.leaves exp
+  CreateExportExploration -> ExportExploration $ convertToGraph (EI.toExport exp)
+  LoadExportExploration graph -> LoadExploration $ EI.fromExport exp (convertFromGraph graph)
+
+convertToGraph :: (Ref, [(Ref, Config)], [(Ref, Ref, (Program, [Output]))]) -> ExecutionGraph
+convertToGraph (cid, nodes, edges) = ExecutionGraph{current=cid, nodes=(map convertToN nodes), edges=(map convertToEdges edges)}
+
+convertFromGraph :: ExecutionGraph -> (Ref, [(Ref, Config)], [(Ref, Ref, (Program, [Output]))])
+convertFromGraph graph = (current graph, map convertFromN (nodes graph), map convertFromEdges (edges graph))
+
+convertToN :: (Ref, Config) -> N
+convertToN (r, c) = N{ref=r, config=c}
+
+convertFromN :: N -> (Ref, Config) 
+convertFromN n = (ref n, config n)
+
+convertToEdges :: (Ref, Ref, (Program, [Output])) -> Edge
+convertToEdges (sid, tid, (p, o)) = Edge{source=sid, target=tid, po=PO{program=p, output=o}}
+
+convertFromEdges :: Edge -> (Ref, Ref, (Program, [Output]))
+convertFromEdges edge = (source edge, target edge, convertFromPO (po edge))
 
+convertFromPO :: PO -> (Program, [Output])
+convertFromPO po = (program po, output po)
diff --git a/src/Parse.hs b/src/Parse.hs
index 056bc64..23ec073 100644
--- a/src/Parse.hs
+++ b/src/Parse.hs
@@ -21,7 +21,7 @@ lexer_settings = emptyLanguage {
   , keywords =  ["!?","||", "&&", "<=", ">=", "..", "True", "False", "Sum", "==", "!=", "When", "Where","Holds when",  "Holds", "Present when", "Present", "Max", "Min", "Count", "Union", "Enabled", "Violated when", "Violated"
                 , "Atom", "String", "Int", "Time", "Current Time"
                 , "Exists", "Forall", "Foreach", "Force", "Reconfigure"
-                , "Extend", "Event", "Act", "Physical","Fact", "Invariant", "Predicate", "Duty", "Actor", "Holder", "Claimant", "Recipient", "Related to", "Conditioned by", "Creates", "Terminates", "Terminated by", "With" , "Identified by", "Derived from", "Derived externally", "Enforced by", "Syncs with"
+                , "Extend", "Event", "Act", "Physical","Fact", "Invariant", "Predicate", "Duty", "Actor", "Holder", "Claimant", "Recipient", "Related to", "Conditioned by", "Creates", "Terminates", "Terminated by", "With" , "Identified by", "Derived from", "Derived externally", "Enforced by"
                 , "Do", "Placeholder", "For", "Not" 
                 , "#", "##", "###", "####"
                 , "#include", "#require"
@@ -194,11 +194,10 @@ frame = "frame" <:=>
           <||> make_act <$$
                 keyword "Physical" <**> id_lit <** optional (keyword "With") <**
                 keyword "Actor" <**> var <**> optional (keyword "Recipient" **> var) <**> 
-                objects <**> syn_domain_constraint <**> precondition <**> postconditions <**>
-                optionalWithDef synchronisations [] <**> 
+                objects <**> syn_domain_constraint <**> precondition <**> postconditions <**> 
                 satisfy (Just (\d -> [Dv [Var d ""] (Ref (Var d ""))]))
-          where make_act ty act mrec attrs dom_filter conds effs ss ot = (ty, TypeSpec {
-                  kind = Act (ActSpec {conditions = conds, effects = effs, syncs = ss} ),
+          where make_act ty act mrec attrs dom_filter conds effs ot = (ty, TypeSpec {
+                  kind = Act (ActSpec {conditions = conds, effects = effs} ),
                   domain = Products (act:((maybe [] (:[]) mrec)++attrs)), 
                   domain_constraint = dom_filter,
                   derivation = fmap ($ ty) ot } )
@@ -250,7 +249,7 @@ syn_pred_decl cons = "pred-type-decl" <:=> cons <$$
 
 syn_inv_decl :: (DomId -> Term -> a) -> BNF Token a
 syn_inv_decl cons = "inv-type-decl" <:=> cons <$$
-  keyword "Invariant" <**> id_lit <** keychar ':' <**> value_expr  
+  keyword "Invariant" <**> id_lit <** keyword "Where" <**> value_expr  
 
 syn_domain_constraint = optionalWithDef (keyword_when **> value_expr) (BoolLit True)
 
@@ -263,19 +262,18 @@ syn_duty_decl cons = "duty-type-decl" <:=> cons <$$
   optionalWithDef (keyword "Violated when" **> multipleSepBy1 value_expr (keychar ',')) [] <**>
   optional (keyword "Enforced by" **> multipleSepBy1 id_lit (keychar ',')) 
 
-syn_act_decl :: (DomId -> Var -> Var -> [Var] -> Term -> [Term] -> [Effect] -> [Sync] -> Maybe (DomId -> [Derivation]) -> a) -> BNF Token a
+syn_act_decl :: (DomId -> Var -> Var -> [Var] -> Term -> [Term] -> [Effect] -> Maybe (DomId -> [Derivation]) -> a) -> BNF Token a
 syn_act_decl cons = "act-type-decl" <:=> cons <$$ 
   keyword "Act" <**> id_lit <** optional (keyword "With") <**
   keyword "Actor" <**> var <** keyword "Recipient" <**> var <**> 
   objects <**> syn_domain_constraint <**> precondition <**>
-  postconditions <**> optionalWithDef synchronisations [] <**> optional derivation_from 
+  postconditions <**> optional derivation_from 
 
-ext_act ty pres efs ss mdv = ActExt ty pres (fmap ($ ty) mdv) efs ss
+ext_act ty pres efs mdv = ActExt ty pres (fmap ($ ty) mdv) efs 
 syn_act_ext :: BNF Token TypeExt 
 syn_act_ext = "act-type-ext" <:=> ext_act <$$
   keyword "Act" <**> id_lit <**> 
-  precondition <**> postconditions <**> optionalWithDef synchronisations [] <**> 
-  optional derivation_from 
+  precondition <**> postconditions <**> optional derivation_from 
 
 ext_event ty efs mdv = EventExt ty (fmap ($ ty) mdv) efs 
 syn_event_ext :: BNF Token TypeExt
@@ -326,10 +324,6 @@ effect dir = identifier
         cons_all   | dir        = CAll
                    | otherwise  = TAll
 
-synchronisations :: BNF Token [Sync]
-synchronisations = "synchronisations"
-  <:=> keyword "Syncs with" **> multipleSepBy1 (opt_foreach Sync) (keychar ',')
-
 application :: (DomId -> Arguments -> a) -> BNF Token a
 application cons = "application" <:=> cons <$$> id_lit <**> arguments
 
@@ -448,8 +442,8 @@ syn_phrase = "phrase"
   where make_fact mactor ty dom domf mdv = FactTypeDecl mactor ty dom domf (fmap ($ ty) mdv)
         make_duty ty h c objs domf mdv mvt mefs =   
           DutyTypeDecl ty (Products (h:(c:objs))) domf (fmap ($ ty) mdv) mvt mefs
-        make_act ty a r objs domf con efs syncs mdv = 
-          ActTypeDecl ty (Products (a:(r:objs))) domf (fmap ($ ty) mdv) con efs syncs
+        make_act ty a r objs domf con efs mdv = 
+          ActTypeDecl ty (Products (a:(r:objs))) domf (fmap ($ ty) mdv) con efs
         make_event ty objs domf efs dv = 
           EventTypeDecl ty (Products objs) domf (dv ty) efs
 
diff --git a/src/Print.hs b/src/Print.hs
index d5897e6..6e4e4e7 100644
--- a/src/Print.hs
+++ b/src/Print.hs
@@ -21,8 +21,8 @@ ppPhrase p = case p of
   PSkip             -> ""
   PExt ext          -> ppExt ext 
 
-instance Show Phrase where
-  show = ppPhrase
+-- instance Show Phrase where
+  -- show = ppPhrase
 
 ppCPhrase :: CPhrase -> String
 ppCPhrase p = case p of 
@@ -50,8 +50,19 @@ ppSpec spec = seq $
 
 ppExt ext = "Type extension of " ++ id_of_ext ext
 
+-- ppTypeDecl :: TypeDecl -> String
+-- ppTypeDecl td = "Typedecl for " ++ (id_of td) 
+
 ppTypeDecl :: TypeDecl -> String
-ppTypeDecl td = "Typedecl for " ++ (id_of td) 
+ppTypeDecl td = case td of 
+  FactTypeDecl bool domainID domain domain_constr derivations    -> "Fact " ++ domainID ++ 
+                                                                    " Identified by " ++ ppDom domain domain_constr ++ 
+                                                                    ppDerivRules (derivations)
+  PredTypeDecl domainID domain_constr          -> "Pred" -- Not needed?
+  InvTypeDecl domainID domain_constr           -> "Invariant " ++ domainID ++ ppConstraint (domain_constr)
+  DutyTypeDecl domainID domain domain_constr derivations violated_when enforcing_acts  -> ppDuty' domainID domain domain_constr derivations violated_when
+  ActTypeDecl domainID domain domain_constr derivations conditions effects -> ppAct' domainID domain domain_constr derivations conditions effects
+  EventTypeDecl domainID domain domain_constr derivations effects -> ppEvent' domainID domain domain_constr (Just derivations) effects
 
 ppDecl :: DomId -> TypeSpec -> String
 ppDecl d tspec = case kind tspec of
@@ -64,14 +75,33 @@ ppDirective :: Directive -> String
 ppDirective (Include fp) = "#include" ++ show fp
 ppDirective (Require fp) = "#require" ++ show fp
 
-ppAct d tspec aspec = 
-  "Act " ++ d ++ " Actor " ++ show actor ++ " Recipient " ++ show recipient ++ show_objects 
-    ++ ppConstraint (domain_constraint tspec)
-    ++ ppPreConditions (conditions aspec)
-    ++ created_facts ++ terminated_facts 
-    ++ ppDerivRules (derivation tspec)
-  where Products (actor:recipient:objects) = domain tspec
-        (createds, terminateds) = partition op (effects aspec)
+ppAct d tspec aspec = ppAct' d (domain tspec) 
+                             (domain_constraint tspec) (derivation tspec) 
+                             (conditions aspec) (effects aspec)
+  -- "Act " ++ d ++ " Actor " ++ show actor ++ " Recipient " ++ show recipient ++ show_objects 
+  --   ++ ppConstraint (domain_constraint tspec)
+  --   ++ ppPreConditions (conditions aspec)
+  --   ++ created_facts ++ terminated_facts 
+  --   ++ ppDerivRules (derivation tspec)
+  -- where Products (actor:recipient:objects) = domain tspec
+  --       (createds, terminateds) = partition op (effects aspec)
+  --        where op (CAll _ _) = True
+  --              op (TAll _ _) = False  
+  --       created_facts | null createds = ""
+  --                     | otherwise     = " Creates " ++ intercalate ", " (map ppEffect createds)
+  --       terminated_facts | null terminateds = ""
+  --                        | otherwise = " Terminates " ++ intercalate ", " (map ppEffect terminateds)
+  --       show_objects | null objects = ""
+  --                    | otherwise    = " Related to " ++ intercalate ", " (map show objects)
+
+ppAct' domainID domain domain_constr derivations conditions effects = 
+  "Act " ++ domainID ++ " Actor " ++ ppVar actor ++ " Recipient " ++ ppVar recipient ++ show_objects
+    ++ ppConstraint (domain_constr)
+    ++ ppPreConditions (conditions)
+    ++ created_facts ++ terminated_facts
+    ++ ppDerivRules (derivations)
+  where Products (actor:recipient:objects) = domain
+        (createds, terminateds) = partition op effects
          where op (CAll _ _) = True
                op (TAll _ _) = False  
         created_facts | null createds = ""
@@ -81,19 +111,38 @@ ppAct d tspec aspec =
         show_objects | null objects = ""
                      | otherwise    = " Related to " ++ intercalate ", " (map show objects)
 
+
 ppPreConditions :: [Term] -> String
 ppPreConditions [] = ""
 ppPreConditions ts = " Conditioned by " ++ intercalate ", " (map ppTerm ts)
 
-ppEvent d tspec espec = 
-  "Event " ++ d ++ show_objects
-    ++ ppConstraint (domain_constraint tspec)
+ppEvent d tspec espec = ppEvent' d (domain tspec) 
+                                 (domain_constraint tspec) (derivation tspec) 
+                                 (event_effects espec)
+  -- "Event " ++ d ++ show_objects
+  --   ++ ppConstraint (domain_constraint tspec)
+  --   ++ created_facts ++ terminated_facts 
+  --   ++ ppDerivRules (derivation tspec)
+  -- where (createds, terminateds) = partition op (event_effects espec)
+  --        where op (CAll _ _) = True
+  --              op (TAll _ _) = False  
+  --       Products objects = domain tspec
+  --       created_facts | null createds = ""
+  --                     | otherwise     = " Creates " ++ intercalate ", " (map ppEffect createds)
+  --       terminated_facts | null terminateds = ""
+  --                        | otherwise = " Terminates " ++ intercalate ", " (map ppEffect terminateds)
+  --       show_objects | null objects = ""
+  --                    | otherwise    = " Related to " ++ intercalate ", " (map show objects)
+
+ppEvent' domainID domain domain_constr derivations effects =
+  "Event " ++ domainID ++ show_objects
+    ++ ppConstraint domain_constr
     ++ created_facts ++ terminated_facts 
-    ++ ppDerivRules (derivation tspec)
-  where (createds, terminateds) = partition op (event_effects espec)
+    ++ ppDerivRules derivations
+  where (createds, terminateds) = partition op effects
          where op (CAll _ _) = True
                op (TAll _ _) = False  
-        Products objects = domain tspec
+        Products objects = domain
         created_facts | null createds = ""
                       | otherwise     = " Creates " ++ intercalate ", " (map ppEffect createds)
         terminated_facts | null terminateds = ""
@@ -119,17 +168,30 @@ ppDerivRules deriv = case deriv of
                                         op _             = []
                         Just ts -> "\n  Derived from " ++ intercalate ", " (map ppDeriv ts)
 
-ppDuty d tspec dspec = 
-  "Duty " ++ d ++ " Holder " ++ show holder ++ " Claimant " ++ show claimant ++ show_objects
-          ++ ppConstraint (domain_constraint tspec)
-          ++ ppDerivRules (derivation tspec)
+ppDuty d tspec dspec = ppDuty' d (domain tspec) (domain_constraint tspec) 
+                               (derivation tspec) (violated_when dspec)
+  -- "Duty " ++ d ++ " Holder " ++ show holder ++ " Claimant " ++ show claimant ++ show_objects
+  --         ++ ppConstraint (domain_constraint tspec)
+  --         ++ ppDerivRules (derivation tspec)
+  --         ++ violation_rule
+  -- where Products (holder:claimant:objects) = domain tspec 
+  --       violation_rule = case violated_when dspec of 
+  --                         []  -> ""
+  --                         ts  -> "\n  Violated when " ++ intercalate ", " (map ppTerm ts)
+  --       show_objects | null objects = ""
+  --                    | otherwise    = " Related to " ++ intercalate ", " (map show objects)
+
+
+ppDuty' domainID domain domain_constr derivations violated_when = 
+  "Duty " ++ domainID ++ " Holder " ++ ppVar holder ++ " Claimant " ++ ppVar claimant ++ show_objects
+          ++ ppConstraint (domain_constr)
+          ++ ppDerivRules (derivations)
           ++ violation_rule
-  where Products (holder:claimant:objects) = domain tspec 
-        violation_rule = case violated_when dspec of 
+   where Products (holder:claimant:objects) = domain
+         violation_rule = case violated_when of 
                           []  -> ""
                           ts  -> "\n  Violated when " ++ intercalate ", " (map ppTerm ts)
-        show_objects | null objects = ""
-                     | otherwise    = " Related to " ++ intercalate ", " (map show objects)
+         show_objects | null objects = ""
 
 ppDeriv :: Derivation -> String
 ppDeriv ExternalValue = "<EXTERNAL>"
@@ -143,7 +205,8 @@ ppDom dom c = types ++ ppConstraint c
                   Ints is     -> intercalate ", " (map show is)
                   AnyString   -> "String"
                   AnyInt      -> "Int"
-                  Products rs -> intercalate " * " (map show rs)
+                  -- Products rs -> intercalate " * " (map show rs)
+                  Products rs -> intercalate " * " (map ppVar rs)
                   Time        -> "<TIME>"
                   External    -> "<EXTERNAL>"
 
@@ -172,10 +235,10 @@ ppTerm t = case t of
   Neq t1 t2 -> app_infix "!=" (ppTerm t1) (ppTerm t2)
   Exists vs t -> exists vs (ppTerm t)
   Forall vs t -> forall vs (ppTerm t)
-  Count vs t  -> binder "Count" vs (ppTerm t)
-  Sum vs t    -> binder "Sum" vs (ppTerm t)
-  Max vs t    -> binder "Max" vs (ppTerm t)
-  Min vs t    -> binder "Min" vs (ppTerm t)
+  Count vs t  -> "Count" ++ foreach vs (ppTerm t)
+  Sum vs t    -> "Sum" ++ foreach vs (ppTerm t)
+  Max vs t    -> "Max" ++ foreach vs (ppTerm t)
+  Min vs t    -> "Min" ++ foreach vs (ppTerm t)
   When t1 t2  -> app_infix "When" (ppTerm t1) (ppTerm t2)
   Present t   -> app "Holds" [ppTerm t]
   Violated t  -> app "Violated" [ppTerm t] 
diff --git a/src/REPL.hs b/src/REPL.hs
index cdd83d3..9116bb9 100644
--- a/src/REPL.hs
+++ b/src/REPL.hs
@@ -5,7 +5,7 @@ module Main where
 import Spec
 import NewExplorer
 import qualified Language.Explorer.Pure as EI 
-import Interpreter(Config(..), errors, violations, query_ress, Output)
+import Interpreter(Config(..), errors, violations, query_ress, Output, get_transition)
 import Parse
 import Print (ppSpec, ppDecl)
 import State
@@ -72,7 +72,7 @@ compile_and_init opts f r i s = case compile_all f r i s of
     Right (spec',r',i',s') -> do
       let spec = refine_specification spec' r'
       state <- make_initial_state spec i'
-      let explorer = init_explorer (Just (spec,state))
+      let explorer = init_explorer spec state
       let ((_,c0),_,(sid, ctx)) = get_last_edge explorer (EI.currRef explorer)
       display_commands
       display_info [] c0 ctx
@@ -81,7 +81,7 @@ compile_and_init opts f r i s = case compile_all f r i s of
 
 init_with_phrases :: Options -> [Either Directive Phrase] -> IO ()
 init_with_phrases opts ps = do
-  let explorer = init_explorer Nothing
+  let explorer = init_explorer emptySpec emptyState
   explorer <- repl_directive_phrases opts ps explorer
   runInputT defaultSettings (repl opts explorer)
 
@@ -115,14 +115,11 @@ repl opts exp = do
       ("#include", fp') -> lift (repl_directive opts (Include fp) exp) >>= continue 
         where fp = case readMaybe fp' of Nothing  -> dropWhile isSpace fp' 
                                          Just str -> str
-      ("#require", fp') -> lift (repl_directive opts (Require fp) exp) >>= continue 
-        where fp = case readMaybe fp' of Nothing  -> dropWhile isSpace fp' 
-                                         Just str -> str
       _                 -> repl_recognize_phrase input
   where continue = repl opts
         repl_trigger b ctx mint = case readMaybe (dropWhile isSpace mint) of
           Just trig | trig <= length (rest_transitions ctx), trig > 0
-            -> lift (repl_phrase opts (PDo b (fst $ rest_transitions ctx !! (trig - 1))) exp) >>= continue
+            -> lift (repl_phrase opts (PDo b (fst $ map get_transition (rest_transitions ctx) !! (trig - 1))) exp) >>= continue
           _ -> lift display_commands >> continue exp
 
         repl_recognize_phrase str = case parse_component syn_phrases str of
@@ -245,7 +242,7 @@ display_new_invariants prev cur = do
           where op i = putStrLn (pref ++ i)
 
 display_all_triggers :: Config -> IO ()
-display_all_triggers cfg = display_triggers "" (rest_transitions cfg)
+display_all_triggers cfg = display_triggers "" (map get_transition (rest_transitions cfg))
 
 display_triggers str tes = display_triggers' tes 
  where  display_triggers' []  = putStrLn ("no " ++ str ++ "actions or events")
diff --git a/src/Server.hs b/src/Server.hs
index 3675732..9c0ff3a 100644
--- a/src/Server.hs
+++ b/src/Server.hs
@@ -1,8 +1,9 @@
 {-# LANGUAGE OverloadedStrings, LambdaCase #-}
+{-# LANGUAGE RecordWildCards #-}
 
 import Spec hiding (Value(..))
 import State
-import Util 
+import Util
 import Options
 import StaticEval
 import Parse
@@ -28,37 +29,38 @@ import System.IO.Error
 import System.Environment (getArgs)
 import System.Directory
 import System.FilePath
-import Network.Socket 
+import Network.Socket
 import qualified Data.ByteString.Lazy.Char8 (pack,unpack)
 
 import Data.Aeson hiding (String, Value(..),Options(..))
 import qualified Data.Aeson as JSON
 
+import qualified Data.Map as M
 -- determines which variant of execution graph to use
-init_explorer = init_stack_explorer
+init_explorer = init_tree_explorer
 
 main :: IO ()
 main = do
-  args <- getArgs 
-  cdir <- getCurrentDirectory 
-  case args of 
-    (f:p:opts) | ".eflint" `isSuffixOf` f, Just port_nr <- readMaybe p ->  do 
+  args <- getArgs
+  cdir <- getCurrentDirectory
+  case args of
+    (f:p:opts) | ".eflint" `isSuffixOf` f, Just port_nr <- readMaybe p ->  do
                   fcont <- readFile f
                   opts' <- run_options (["-i",takeDirectory f,"-i",cdir] ++ opts)
                   case parse_component syn_directives_phrases fcont of
                     Left err1 -> case parse_flint fcont of
                       Left err2 -> do  putStrLn "could not parse flint phrases:\n" >> putStrLn err1
                                        putStrLn "could not parse flint spec:\n" >> putStrLn err2
-                      Right (s, r, i, _) -> init_server opts' port_nr s r i 
-                    Right ps -> init_with_phrases opts' port_nr ps 
-    (p:opts)   | Just port_nr <- readMaybe p -> do 
+                      Right (s, r, i, _) -> init_server opts' port_nr s r i
+                    Right ps -> init_with_phrases opts' port_nr ps
+    (p:opts)   | Just port_nr <- readMaybe p -> do
       opts <- run_options (["-i",cdir] ++ opts)
-      init_with_phrases opts port_nr []
+      init_server opts port_nr emptySpec emptyRefiner emptyInitialiser
     _ -> putStrLn "please provide: <NAME>.eflint <PORT> <OPTIONS>"
 
 init_with_phrases :: Options -> PortNumber -> [Either Directive Phrase] -> IO ()
 init_with_phrases opts port_nr ps = do
-  let explorer = init_explorer Nothing 
+  let explorer = init_explorer emptySpec emptyState
   run_directives_phrases opts ps (start_server opts port_nr) explorer
   return ()
 
@@ -66,36 +68,38 @@ type Cont a = Explorer -> IO a
 
 run_directives_phrases :: Options -> [Either Directive Phrase] -> Cont a -> Cont a
 run_directives_phrases opts [] cont exp = cont exp
-run_directives_phrases opts (edp:ps) cont exp = let (_,_,(_,ctx)) = get_last_edge exp (EI.currRef exp) in 
-  case edp of 
+run_directives_phrases opts (edp:ps) cont exp = let (_,_,(_,ctx)) = get_last_edge exp (EI.currRef exp) in
+  case edp of
    Left d  -> run_directive opts d (run_directives_phrases opts ps cont) exp
    Right p -> run_phrase opts p (run_directives_phrases opts ps cont) exp
 
 run_phrase :: Options -> Phrase -> Cont a -> Cont a
 run_phrase opts phrase cont exp = case run_ exp (Execute [phrase]) of
-  ResultTrans exp _ _ _  -> cont exp
-  Path _                 -> putStrLn "Unexpected execution path encountered" >> cont exp 
-  Nodes _                -> putStrLn "Unexpected collection of nodes encountered" >> cont exp 
+  ResultTrans exp _ _ _ -> cont exp
+  Path _                 -> putStrLn "Unexpected execution path encountered" >> cont exp
+  Nodes _                -> putStrLn "Unexpected collection of nodes encountered" >> cont exp
   InvalidRevert          -> putStrLn "invalid revert error" >> cont exp
+  ExportExploration _    -> putStrLn "Unexpected export problem of execution graph" >> cont exp
+  LoadExploration _      -> putStrLn "Unexpected load problem of execution graph" >> cont exp
 
 run_directive :: Options -> Directive -> Cont a -> Cont a
-run_directive opts (Require fp) cont exp 
+run_directive opts (Require fp) cont exp
   | has_been_included fp opts = cont exp
   | otherwise                 = run_directive opts (Include fp) cont exp
 run_directive opts (Include fp) cont exp = do
   let dirs = find include_paths opts
-  find_included_file dirs fp >>= \case 
+  find_included_file dirs fp >>= \case
     []       -> putStrLn ("could not find " ++ fp ++ " in " ++ show dirs) >> cont exp
     (file:_) -> do
       add_include_path (takeDirectory file) opts
       add_include file opts
       case ".json" `isSuffixOf` file of
         True -> do
-          mspec <- decode_json_file file 
+          mspec <- decode_json_file file
           case mspec of
             Left err -> putStrLn err >> cont exp
             Right spec -> run_directives_phrases opts [Right (PFrames spec [])] cont exp
-        False -> catchIOError (Right <$> readFile file) handler >>= \case 
+        False -> catchIOError (Right <$> readFile file) handler >>= \case
           Left err  -> putStrLn err >> cont exp
           Right str -> case parse_component syn_directives_phrases str of
             Left err -> putStrLn err >> cont exp
@@ -108,14 +112,14 @@ run_directive opts (Include fp) cont exp = do
 
 
 
-init_server :: Options -> PortNumber -> Spec -> Refiner -> Initialiser -> IO () 
+init_server :: Options -> PortNumber -> Spec -> Refiner -> Initialiser -> IO ()
 init_server opts port_nr spec' ref' init' = do
   case compile_all spec' ref' init' [] of
     Left errs -> putStrLn "cannot compile specification" >> putStrLn (unlines errs)
     Right (spec', ref, init, _) -> do
       let spec = refine_specification spec' ref
       state <- make_initial_state spec init
-      let explorer = init_explorer (Just (spec, state))
+      let explorer = init_explorer spec state
       start_server opts port_nr explorer
 
 start_server :: Options -> PortNumber -> Cont ()
@@ -127,7 +131,7 @@ start_server opts port_nr explorer = do
       server opts sock  explorer
 
 server :: Options -> Socket -> Cont ()
-server opts = continue 
+server opts = continue
   where continue :: Socket -> Cont ()
         continue sock exp = do
           putStrLn "--- AWAITING STATEMENT ---"
@@ -144,42 +148,65 @@ server opts = continue
                   hClose handle
                   continue sock exp
 --                Explorer.ExecError err    -> report_error (ExecError err) exp
-                Nodes nodes -> do 
+                Nodes nodes -> do
                   hPutStrLn handle (json_encode (GiveNodes nodes))
                   hClose handle
                   continue sock exp
+                ExportExploration exportGraph -> do
+                  putStrLn "--- Exporting ---"
+                  hPutStrLn handle (json_encode (GiveExportGraph exportGraph))
+                  hClose handle
+                  continue sock exp
+                LoadExploration exp -> do
+                  putStrLn "--- Loading execution graph ---"
+                  hPutStrLn handle (json_encode (GiveLoadGraph))
+                  hClose handle 
+                  continue sock exp
                 InvalidRevert             -> report_error InvalidState exp
 --                CompilationError err      -> report_error (InvalidInput err) exp
               report_success sock outputs old_id c0 state_id ctx exp = do
+                let facts_from = state_holds (cfg_state c0)
+                let facts_to = state_holds (cfg_state ctx)
+                let created_facts    = facts_to \\ facts_from
+                let terminated_facts = facts_from \\ facts_to
+
                 let viols = S.fromList (violations outputs)
                 let outs = S.fromList (ex_triggers outputs)
                 let errs = S.fromList (errors outputs)
                 let qress = query_ress outputs
+
                 let transitions = S.fromList (rest_transitions ctx)
                 let new_duties = S.fromList (rest_duties ctx) S.\\ S.fromList (rest_duties c0)
                 let new_enabled = S.fromList (rest_enabled ctx) S.\\ S.fromList (rest_enabled c0)
                 let new_disabled = S.fromList (rest_disabled ctx) S.\\ S.fromList (rest_disabled c0)
                 let all_duties = S.fromList $ rest_duties ctx
-                hPutStrLn handle (json_encode (CommandSuccess state_id viols outs errs qress new_duties all_duties new_enabled new_disabled transitions))
+
+                hPutStrLn handle (json_encode (CommandSuccess old_id state_id
+                                                              facts_from facts_to created_facts terminated_facts
+                                                              viols outs errs qress
+                                                              new_duties all_duties
+                                                              new_enabled new_disabled transitions))
                 hClose handle
                 continue sock exp
-              report_error err exp = do 
+              report_error err exp = do
                 hPutStrLn handle (json_encode err)
                 hClose handle
                 continue sock exp
           let do_event event_type term = compile_and (event_type term)
-          let withCommand cmd = case cmd of 
+          let withCommand cmd = case cmd of
                 CreateEvent term    -> do_event (Create []) term
-                TerminateEvent term -> do_event (Terminate []) term 
+                TerminateEvent term -> do_event (Terminate []) term
                 QueryCommand term   -> compile_and (PQuery term)
                 Revert new_state    -> report $ run_ exp (Explorer.Revert new_state)
                 Status mid          -> report $ run_ exp (Display (maybe (EI.currRef exp) id mid))
                 History mid         -> report $ run_ exp (DisplayFull (maybe (EI.currRef exp) id mid))
                 Heads               -> report $ run_ exp ExplorationHeads
+                CreateExport        -> report $ run_ exp CreateExportExploration
+                LoadExport graph    -> report $ run_ exp (LoadExportExploration graph)
                 GetFacts            -> do hPutStrLn handle (json_encode (GiveFacts (state_holds (cfg_state ctx))))
                                           hClose handle
                                           continue sock exp
-                Kill                -> hPutStrLn handle (json_encode ByeBye) >> hClose handle 
+                Kill                -> hPutStrLn handle (json_encode ByeBye) >> hClose handle
                 ActionCommand d a r os force -> compile_and (PTrigger force [] term)
                   where term = App d (Left (a : r : os))
                 CmdTrigger t b      -> compile_and (PTrigger b [] t)
@@ -191,15 +218,15 @@ server opts = continue
                   Left err  -> do hPutStrLn handle (json_encode (InvalidInput err))
                                   hClose handle >> continue sock exp
                   Right ps  -> report $ run_ exp (Execute ps)
-          case eitherDecode (Data.ByteString.Lazy.Char8.pack string) of 
+          case eitherDecode (Data.ByteString.Lazy.Char8.pack string) of
             Left err -> do when (find debug opts) (putStrLn err)
                            case (find accept_phrases opts) of
                             False -> do hPutStrLn handle (json_encode (InvalidCommand err))
                                         hClose handle
                                         continue sock exp
-                            True  -> withCommand (Phrase string) 
-            Right cmd-> withCommand cmd 
-                 
+                            True  -> withCommand (Phrase string)
+            Right cmd-> withCommand cmd
+
 json_encode r = Data.ByteString.Lazy.Char8.unpack (encode r)
 
 data Command    = ActionCommand DomId Term Term [Term] Bool
@@ -209,18 +236,20 @@ data Command    = ActionCommand DomId Term Term [Term] Bool
                 | QueryCommand Term
                 | StringInstances DomId [String]
                 | IntInstances DomId [Int]
-                | Revert Int 
+                | Revert Int
                 | Status (Maybe Int)
                 | Kill
                 | GetFacts
                 | History (Maybe Int)
                 | Heads
+                | CreateExport
+                | LoadExport ExecutionGraph
                 | Phrase String
 
 instance FromJSON Command where
-  parseJSON = withObject "Command" $ \v -> do 
+  parseJSON = withObject "Command" $ \v -> do
                 cmd <- v .: "command"
-                case cmd::String of 
+                case cmd::String of
                   "create"      -> CreateEvent . value_to_term <$> v .: "value"
                   "terminate"   -> TerminateEvent . value_to_term <$> v .: "value"
                   "test-present"-> QueryCommand . value_to_term <$> v .: "value"
@@ -228,20 +257,22 @@ instance FromJSON Command where
                   "enabled"     -> QueryCommand . Enabled . value_to_term <$> v .: "value"
                   "revert"      -> Revert <$> v .: "value"
                   "action"      -> full_action <|> trigger_action
-                    where full_action = 
-                            actionCommand <$> 
+                    where full_action =
+                            actionCommand <$>
                                     v .: "act-type" <*> v .: "actor" <*> v .: "recipient"
                                <*>  v .: "objects"  <*> maybe_force v
-                          trigger_action = CmdTrigger . value_to_term <$> v .: "value" <*> maybe_force v 
+                          trigger_action = CmdTrigger . value_to_term <$> v .: "value" <*> maybe_force v
                           actionCommand d a r os = ActionCommand d (to_term a) (to_term r) (map to_term os)
                   "status"      -> Status <$> v .: "state"
                                 <|> return (Status Nothing)
                   "history"     ->  History <$> v .: "state"
                                 <|> return (History Nothing)
                   "trace-heads" -> return Heads
+                  "create-export" -> return CreateExport
+                  "load-export" -> LoadExport <$> v .: "graph"
                   "kill"        -> return Kill
                   "phrase"      -> Phrase <$> v .: "text"
-                  "event"       -> CmdTrigger . value_to_term <$> v .: "value" <*> maybe_force v 
+                  "event"       -> CmdTrigger . value_to_term <$> v .: "value" <*> maybe_force v
                   "instances-of"-> StringInstances <$> v .: "fact-type" <*> v .: "instances"
                                <|> IntInstances <$> v .: "fact-type" <*> v .: "instances"
                   "facts"       -> return GetFacts
@@ -255,9 +286,9 @@ data Value      = Atom DomId (Either String Int)
 data StringOrValue = ST String | VT Value
 
 instance FromJSON StringOrValue where
-  parseJSON v = case v of 
+  parseJSON v = case v of
     JSON.String str -> return (ST (unpack str))
-    JSON.Object obj -> VT <$> parseJSON v 
+    JSON.Object obj -> VT <$> parseJSON v
     _               -> fail ("looking for a string or a value, not a " ++ show v)
 
 to_term :: StringOrValue -> Term
@@ -270,7 +301,7 @@ tag_of (Composite d _) = d
 
 value_to_term :: Value -> Term
 value_to_term v = case v of
-  Atom d (Left s)  -> App d (Left [StringLit s]) 
+  Atom d (Left s)  -> App d (Left [StringLit s])
   Atom d (Right i) -> App d (Left [IntLit i])
   Composite d vs   -> App d (Right $ map value_to_modifier vs)
 
@@ -278,7 +309,7 @@ value_to_modifier :: Value -> Modifier
 value_to_modifier v = Rename (no_decoration (tag_of v)) (value_to_term v)
 
 instance FromJSON Value where
-  parseJSON = withObject "Value" $ \v -> 
+  parseJSON = withObject "Value" $ \v ->
                     (\c i -> Atom c (Right i)) <$> v .: "fact-type" <*> v .: "value"
                 <|> (\c s -> Atom c (Left s))  <$> v .: "fact-type" <*> v .: "value"
                 <|> Composite <$> v .: "fact-type" <*> v .: "value"
@@ -286,30 +317,49 @@ instance FromJSON Value where
 
 data Response   = InvalidCommand String
                 | InvalidInput String -- parse error
-                | CommandSuccess Int (S.Set Violation) 
-                                     (S.Set OutputEvent)
-                                     (S.Set Error) -- errors: compilation + transition
-                                     [QueryRes]         -- query results 
-                                     (S.Set Tagged) -- new duties
-                                     (S.Set Tagged) -- all duties in the current state 
-                                     (S.Set Tagged) -- newly enabled transitions 
-                                     (S.Set Tagged) -- newly disabled transitions
-                                     (S.Set (Tagged, Bool)) -- all transitions 
+                | CommandSuccess Int -- Source node ID
+                                 Int -- Target node ID
+                                 [Tagged] -- source node facts
+                                 [Tagged] -- target node facts
+                                 [Tagged] -- created facts
+                                 [Tagged] -- deleted facts
+                                 (S.Set Violation)
+                                 (S.Set OutputEvent)
+                                 (S.Set Error) -- errors: compilation + transition
+                                 [QueryRes]         -- query results
+                                 (S.Set Tagged) -- new duties
+                                 (S.Set Tagged) -- all duties in the current state
+                                 (S.Set Tagged) -- newly enabled transitions
+                                 (S.Set Tagged) -- newly disabled transitions
+                                 (S.Set Transition) -- all transitions
                 | InvalidState
                 | GiveFacts [Tagged]
                 | GivePath Path
                 | GiveNodes [Node]
+                | GiveExportGraph ExecutionGraph
+                | GiveLoadGraph
                 | ByeBye
 
 instance ToJSON Response where
   toJSON (InvalidCommand err) = object [ "response" .= JSON.String "invalid command", "message" .= toJSON err ]
-  toJSON (CommandSuccess i vs outs errs qress new_duties all_duties new_enabled new_disabled all_transitions) = 
+  toJSON (CommandSuccess sid_from i
+                         facts_from facts_to created_facts terminated_facts
+                         vs outs errs qress
+                         new_duties all_duties
+                         new_enabled new_disabled all_transitions) =
     object [ "response"   .= JSON.String "success"
+           , "old-state" .= toJSON sid_from
+           , "new-state"  .= toJSON i
+           , "source_contents"  .= toJSON (map TaggedJSON facts_from)
+           , "target_contents"  .= toJSON (map TaggedJSON facts_to)
+           , "created_facts"    .= toJSON (map TaggedJSON created_facts)
+           , "terminated_facts" .= toJSON (map TaggedJSON terminated_facts)
+
            , "violations" .= toJSON vs
            , "output-events" .= toJSON outs
            , "errors"     .= toJSON errs
            , "query-results" .= toJSON qress
-           , "new-state"  .= toJSON i
+
            , "new-duties" .= toJSON (map TaggedJSON $ S.toList new_duties)
            , "new-enabled-transitions" .= toJSON (map TaggedJSON $ S.toList new_enabled)
            , "new-disabled-transitions" .= toJSON (map TaggedJSON $ S.toList new_disabled)
@@ -317,58 +367,132 @@ instance ToJSON Response where
            , "all-disabled-transitions" .= toJSON (map TaggedJSON dis_transitions)
            , "all-enabled-transitions" .= toJSON (map TaggedJSON en_transitions)
            ]
-   where en_transitions = map fst $ filter snd $ S.toList all_transitions 
-         dis_transitions = map fst $ filter (not . snd) $ S.toList all_transitions 
+   where en_transitions = map fst $ filter snd $ map get_transition (S.toList all_transitions)
+         dis_transitions = map fst $ filter (not . snd) $ map get_transition (S.toList all_transitions)
   toJSON InvalidState       = object [ "response" .= JSON.String "invalid state" ]
-  toJSON (InvalidInput err) = object [ "response" .= JSON.String "invalid input" 
+  toJSON (InvalidInput err) = object [ "response" .= JSON.String "invalid input"
                                      , "error"    .= toJSON err ]
   toJSON ByeBye             = object [ "response"  .= JSON.String "bye world.." ]
   toJSON (GiveFacts tes)    = object [ "values" .= toJSON (map TaggedJSON tes) ]
   toJSON (GiveNodes nodes)  = object [ "nodes"  .= toJSON (map toJSONNode nodes) ]
-    where toJSONNode (sid, cfg) = 
-            object [ "state_id"       .= toJSON sid
-                   , "state_contents" .= toJSON (map TaggedJSON (state_holds (cfg_state cfg))) ]
+    where toJSONNode (sid, cfg) =
+            object [ "state_id"             .= toJSON sid
+                   , "state_contents"       .= toJSON (map TaggedJSON (state_contents))
+                   , "duties"               .= toJSON (map TaggedJSON $ S.toList all_duties)
+                   , "disabled-transitions" .= toJSON (map TaggedJSON dis_transitions)
+                   , "enabled-transitions"  .= toJSON (map TaggedJSON en_transitions)
+                   ]
+             where state_contents = state_holds (cfg_state cfg)
+                   all_duties = S.fromList $ rest_duties cfg
+                   all_transitions = S.fromList (map get_transition (rest_transitions cfg))
+                   en_transitions = map fst $ filter snd $ S.toList all_transitions
+                   dis_transitions = map fst $ filter (not . snd) $ S.toList all_transitions
+
   toJSON (GivePath edges)   = object [ "edges"  .= toJSON (map toJSONEdge edges') ]
     where edges' = sortBy (on compare (\((sid,_),_,_) -> sid)) edges
-          toJSONEdge ((sid_from,ctx_from), (phr, output), (sid_to, ctx_to)) = 
-            object [ "source_id"        .= toJSON sid_from
-                   , "source_contents"  .= toJSON (map TaggedJSON facts_from)
-                   , "phrase"           .= toJSON (ppPhrase phr)
+          toJSONEdge ((sid_from,ctx_from), (phr, output), (sid_to, ctx_to)) =
+            object [ "phrase"           .= toJSON (ppPhrase phr)
+                   , "source_id"        .= toJSON sid_from
                    , "target_id"        .= toJSON sid_to
+
+                   , "source_contents"  .= toJSON (map TaggedJSON facts_from)
                    , "target_contents"  .= toJSON (map TaggedJSON facts_to)
                    , "created_facts"    .= toJSON (map TaggedJSON created)
                    , "terminated_facts" .= toJSON (map TaggedJSON terminated)
+
                    , "violations"       .= toJSON rep_viols
-                   , "output"           .= toJSON output
+                   -- , "output"           .= toJSON output
+                   , "output-events"    .= toJSON outs
+                   , "errors"           .= toJSON errs
+                   , "query-results"    .= toJSON qress
+
+                   , "new-duties" .= toJSON (map TaggedJSON $ S.toList new_duties)
+                   , "new-enabled-transitions" .= toJSON (map TaggedJSON $ S.toList new_enabled)
+                   , "new-disabled-transitions" .= toJSON (map TaggedJSON $ S.toList new_disabled)
+                   , "all-duties" .= toJSON (map TaggedJSON $ S.toList all_duties)
+                   , "all-disabled-transitions" .= toJSON (map TaggedJSON dis_transitions)
+                   , "all-enabled-transitions" .= toJSON (map TaggedJSON en_transitions)
+
                    ]
            where facts_from = state_holds (cfg_state ctx_from)
                  facts_to   = state_holds (cfg_state ctx_to)
                  created    = facts_to \\ facts_from
-                 terminated = facts_from \\ facts_to  
-                 rep_viols  = violations output 
+                 terminated = facts_from \\ facts_to
+
+                 rep_viols  = violations output
+                 outs = S.fromList (ex_triggers output)
+                 errs = S.fromList (errors output)
+                 qress = query_ress output
+
+                 all_transitions = S.fromList (rest_transitions ctx_to)
+                 en_transitions = map fst $ filter snd $ map get_transition (S.toList all_transitions)
+                 dis_transitions = map fst $ filter (not . snd) $ map get_transition (S.toList all_transitions)
+                 new_duties = S.fromList (rest_duties ctx_to) S.\\ S.fromList (rest_duties ctx_from)
+                 new_enabled = S.fromList (rest_enabled ctx_to) S.\\ S.fromList (rest_enabled ctx_from)
+                 new_disabled = S.fromList (rest_disabled ctx_to) S.\\ S.fromList (rest_disabled ctx_from)
+                 all_duties = S.fromList $ rest_duties ctx_to
+
+  toJSON (GiveExportGraph graph)  = toJSON graph
+  toJSON GiveLoadGraph = object [ "response" .= JSON.String "success" ]
 
 instance ToJSON Violation where
   toJSON (TriggerViolation te is_action) =
     object [ "violation" .= JSON.String "trigger"
            , "value"     .= toJSON (TaggedJSON te)
            , "is-action" .= JSON.Bool is_action ]
-  toJSON (DutyViolation te) = 
+  toJSON (DutyViolation te) =
     object [ "violation" .= toJSON ("duty"::String)
            , "value"     .= toJSON (TaggedJSON te) ]
-  toJSON (InvariantViolation d) = 
+  toJSON (InvariantViolation d) =
     object [ "violation" .= toJSON ("invariant"::String)
            , "invariant" .= toJSON d ]
 
+instance FromJSON Violation where
+  parseJSON = withObject "trigger or duty or invariant violation" $ \o -> do
+    violationtype <- o .: "violation"
+    case violationtype of
+      -- "trigger"   -> TriggerViolation   <$> o .: "value" <*> o .: "is-action"
+      -- "duty"      -> DutyViolation      <$> o .: "value"
+      "trigger"   -> TriggerViolation ((String "test2"), "Test1") <$> o .: "is-action"
+      "duty"      -> return (DutyViolation ((String "test2"), "Test1"))
+      "invariant" -> InvariantViolation <$> o .: "invariant"
+      _           -> fail ("unknown type: " ++ violationtype)
+
 instance ToJSON OutputEvent where
-  toJSON (ExecutedTransition te action) = 
+  toJSON (ExecutedTransition te action) =
     object [ "type"       .= JSON.String "executed-transition"
            , "value"      .= toJSON (TaggedJSON te)
            , "is-action"  .= JSON.Bool action]
 
+instance FromJSON OutputEvent where
+  parseJSON = withObject "output-event" $ \o -> do
+    -- te     <- o .: "value"
+    -- let t = fromJSON te
+    action <- o .: "is-action"
+    return (ExecutedTransition ((String "test2"), "Test1") action)
+    -- return (ExecutedTransition te action)
+
+-- instance FromJSON TaggedJSON where
+--   parseJSON = withObject "string or int or product" $ \o -> do
+--     taggedtype <- o .: "tagged-type"
+--     case taggedtype of
+--       "string"  -> String <$> o .: "value" 
+--       "int"     -> Int <$> o .: "value"
+--       "product" -> Product <$> o .: "arguments" 
+--       _         -> fail ("unknown output: " ++ taggedtype)
+
 instance ToJSON QueryRes where
   toJSON qres = case qres of
-    QuerySuccess -> "success"
-    QueryFailure -> "failure"
+    QuerySuccess -> object [ "query-result" .= JSON.String "success"]
+    QueryFailure -> object [ "query-result" .= JSON.String "failure"]
+
+instance FromJSON QueryRes where
+  parseJSON = withObject "succes or failure" $ \o -> do
+    querytype <- o .: "query-result"
+    case querytype of
+      "success"  -> return QuerySuccess
+      "failure" -> return QueryFailure
+      _         -> fail ("unknown output: " ++ querytype)
 
 instance ToJSON Error where
   toJSON err = case err of
@@ -378,8 +502,554 @@ instance ToJSON Error where
     CompilationError err  -> object ["error-type" .= JSON.String "compilation error"
                                     ,"error" .= toJSON err]
 
+instance FromJSON Error where
+  parseJSON = withObject "NonDeterministicTransition or DisabledTransition or CompilationError" $ \o -> do
+    errortype <- o .: "error-type"
+    case errortype of
+      "non-deterministic transition" -> return NonDeterministicTransition
+      -- "disabled transition"          -> DisabledTransition <$> o .: "value"
+      "disabled transition"          -> return (DisabledTransition ((String "test2"), "Test1"))
+      "compilation error"            -> CompilationError   <$> o .: "error"
+      _                              -> fail ("unknown type: " ++ errortype)
+
+
 instance ToJSON Output where
-  toJSON (OutputEvent e)  = toJSON e
-  toJSON (Violation v)    = toJSON v
-  toJSON (QueryRes r)     = toJSON r
-  toJSON (ErrorVal e)     = toJSON e
+  toJSON (OutputEvent e)  = object [ "output-type" .= JSON.String "output-event", "output" .= e]
+  toJSON (Violation v)    = object [ "output-type" .= JSON.String "violation", "output" .= v]
+  toJSON (QueryRes r)     = object [ "output-type" .= JSON.String "query-res", "output" .= r]
+  toJSON (ErrorVal e)     = object [ "output-type" .= JSON.String "error-val", "output" .= e]
+
+  -- toJSON (OutputEvent e)  = toJSON e
+  -- toJSON (Violation v)    = toJSON v
+  -- toJSON (QueryRes r)     = toJSON r
+  -- toJSON (ErrorVal e)     = toJSON e
+
+instance FromJSON Output where
+  parseJSON = withObject "outputevent or violation or queryres or errorval" $ \o -> do
+    outputtype <- o .: "output-type"
+    case outputtype of
+      "output-event" -> OutputEvent <$> o .: "output" 
+      "violation"    -> Violation <$> o .: "output" 
+      "query-res"    -> QueryRes <$> o .: "output" 
+      "error-val"    -> ErrorVal <$> o .: "output" 
+      _        -> fail ("unknown output: " ++ outputtype)
+
+instance ToJSON Config where
+  toJSON conf = object [
+    "spec"             .= cfg_spec conf,
+    "state"            .= cfg_state conf,
+    "rest_transitions" .= rest_transitions conf,
+    "rest_duties"      .= rest_duties conf
+    ]
+
+instance FromJSON Config where
+  parseJSON = withObject "config" $ \o -> do
+    cfg_spec         <- o .: "spec"
+    cfg_state        <- o .: "state"
+    rest_transitions <- o .: "rest_transitions"
+    rest_duties      <- o .: "rest_duties"
+    return Config{..}
+
+instance ToJSON Elem where
+  toJSON (String el)  = object ["elem-type" .= JSON.String "string",  "elem" .= el]
+  toJSON (Int el)     = object ["elem-type" .= JSON.String "int",     "elem" .= el]
+  toJSON (Product el) = object ["elem-type" .= JSON.String "product", "elem" .= el]
+
+instance FromJSON Elem where
+  parseJSON = withObject "string or int or product" $ \o -> do
+    elemtype <- o .: "elem-type"
+    case elemtype of
+      "string"  -> String <$> o .: "elem"
+      "int"     -> Int <$> o .: "elem"
+      "product" -> Product <$> o .: "elem"
+      _         -> fail ("unknown type: " ++ elemtype)
+
+instance ToJSON Spec where
+  toJSON spec = object [
+    "decls"      .= decls spec,
+    "aliases"    .= aliases spec,
+    "invariants" .= invariants spec,
+    "actors"     .= actors spec
+    ]
+
+instance FromJSON Spec where
+  parseJSON = withObject "spec" $ \o -> do
+    decls      <- o .: "decls"
+    aliases    <- o .: "aliases"
+    invariants <- o .: "invariants"
+    actors     <- o .: "actors"
+    return Spec{..}
+
+instance ToJSON State where
+  toJSON state = object [
+    "contents" .=  show (contents state),
+      -- toJSON (map TaggedJSON (state_holds state)),
+    "time"     .=  (time state)
+    ]
+
+-- TODO fix
+instance FromJSON State where
+  parseJSON = withObject "state" $ \o -> do
+    -- let contents = M.empty
+    contents_show <- o .: "contents"
+    let contents = read contents_show
+    time     <- o .: "time"
+    return State{contents=contents, time=time}
+
+-- instance FromJSON TaggedJSON where
+--   parseJSON = withObject "taggedJSON" $ \o -> do
+--     taggedtype <- o .: "tagged-type"
+--     case elemtype of
+--       "string"  -> String <$> o .: "value"
+--       "int"     -> Int <$> o .: "value"
+--       _         -> fail ("unknown type: " ++ taggedtype)
+-- 
+-- create_contents :: [TaggedJSON] -> M.Map Tagged Meta
+-- create_contents [] = M.empty
+-- create_contents (x:xs) = M.insert (create_tagged x) Meta{} (create_contents' xs)
+-- data MapElem    = MapStrings String String
+                -- | MapInts String Int
+                -- | Products M.Map String String
+                -- deriving (Ord, Eq)
+
+-- instance ToJSON MapElem where
+--   toJSON (MapStrings el)  = object ["map-type" .= JSON.String "string",  "map-elem" .= el]
+--   toJSON (MapInts el)     = object ["map-type" .= JSON.String "int",     "map-elem" .= el]
+--   -- toJSON (MapStrings el) = object ["elem-type" .= JSON.String "product", "elem" .= el]
+-- 
+-- instance FromJSON MapElem 
+  -- parseJSON = withObject "MapElem" $
+  -- parseJSON = withObject "map:string or int or product" $ \o -> do
+    -- let contents = create_contents o
+    -- return o
+    -- maptype <- o .: "map-type"
+    -- case maptype of
+    --   -- "string"  -> MapStrings <$> o .: "map-elem"
+    --   -- "int"     -> MapInts <$> o .: "map-elem"
+    --   _         -> fail ("unknown type: " ++ maptype)
+
+
+-- instance FromJSON MapElem where
+--   parseJSON = withObject "MapElem" $ \o -> do
+--     return (MapStrings M.empty)
+
+-- create_contents' :: [M.Map String String] -> M.Map Tagged Meta
+-- create_contents' [] = M.empty
+-- create_contents' (x:xs) = M.insert (create_tagged x) Meta{} (create_contents' xs)
+-- 
+-- create_contents :: [M.Map String String] -> M.Map Tagged Meta
+-- create_contents tagged_list = create_contents' tagged_list
+-- create_tagged :: (M.Map String String) -> Tagged
+-- -- create_tagged x = (String "test1", "test2")
+-- create_tagged x 
+--   | (get_key_value_str x "tagged-type") == "string" = (String (get_key_value_str x "value"), 
+--                                                        (get_key_value_str x "fact-type"))
+--   | (get_key_value_str x "tagged-type") == "int"    = (Int (get_key_value_int x "value"), 
+--                                                        (get_key_value_str x "fact-type"))
+--   | otherwise                                       = (String "Elem", "DomID")
+  -- | otherwise = (Product (create_tagged_product (get_key_value_prod x "arguments")), 
+                 -- (get_key_value x "fact-type"))
+
+-- create_tagged_product :: x -> [Tagged]
+-- create_tagged_product x = x
+-- create_tagged x = do
+  -- el    <- Elem{(lookup "fact-type" x)}
+  -- el <- case M.lookup "fact-type" x of
+     -- Just value -> value
+     -- Nothing    -> ""
+  -- el    <- case M.lookup "fact-type" x of Nothing -> ""
+                                        -- Just val -> val
+  -- domid <- case lookup "value" x of Nothing -> ""
+                                    -- Just val -> val
+  -- return (String el, "domid")
+  -- return (String "test1", "test2")
+-- create_tagged x = (, )String
+
+-- get_key_value_str :: (M.Map String String) -> String -> String
+-- get_key_value_str object key = do
+--   value <- case M.lookup key object of Nothing -> ""
+--                                        Just val -> val
+--   return value
+-- 
+-- get_key_value_int :: (M.Map String String) -> String -> Int
+-- get_key_value_int object key =
+--   case M.lookup key object of Nothing ->  0 
+--                               -- read "0"::Int
+--                               -- Just val -> val
+--                               Just val -> read (val)::Int
+-- get_key_value_int object key = do
+--   value <- case M.lookup key object of Nothing -> "0"
+--                                        Just val -> String val
+--   return (read value::Int)
+
+instance ToJSON Meta where
+  toJSON meta = object [
+    "meta" .= JSON.String "meta"
+    ]
+
+instance FromJSON Meta where
+  parseJSON = withObject "meta" $ \o -> do
+    return Meta{}
+
+instance ToJSON TypeSpec where
+  toJSON typespec = object [
+    "kind"              .= kind typespec,
+    "domain"            .= domain typespec,
+    "domain_constraint" .= domain_constraint typespec,
+    "derivation"        .= derivation typespec
+    ]
+
+instance FromJSON TypeSpec where
+  parseJSON = withObject "typespec" $ \o -> do
+    kind              <- o .: "kind"
+    domain            <- o .: "domain"
+    domain_constraint <- o .: "domain_constraint"
+    derivation        <- o .:? "derivation"
+    return TypeSpec{..}
+
+instance ToJSON Kind where
+  toJSON (Fact kind)  = object ["kind-type" .= JSON.String "Fact",
+                                "fact" .= kind]
+  toJSON (Act kind)   = object ["kind-type" .= JSON.String "Act",
+                                "act" .= kind]
+  toJSON (Duty kind)  = object ["kind-type" .= JSON.String "Duty",
+                                "duty" .= kind]
+  toJSON (Event kind) = object ["kind-type" .= JSON.String "Event",
+                                  "event" .= kind]
+
+instance FromJSON Kind where
+  parseJSON = withObject "fact or act or duty or event" $ \o -> do
+    kindtype <- o .: "kind-type"
+    case kindtype of
+      "Fact"  -> Fact <$> o .: "fact"
+      "Act"   -> Act <$> o .: "act"
+      "Duty"  -> Duty <$> o .: "duty"
+      "Event" -> Event <$> o .: "event"
+      _       -> fail ("unknown type: " ++ kindtype)
+
+instance ToJSON FactSpec where
+  toJSON factspec = object [
+    "invariant" .= invariant factspec,
+    "actor"     .= actor factspec
+    ]
+
+instance FromJSON FactSpec where
+  parseJSON = withObject "factsspec" $ \o -> do
+    invariant <- o .: "invariant"
+    actor  <- o .: "actor"
+    return FactSpec{..}
+
+instance ToJSON ActSpec where
+  toJSON actspec = object [
+    "conditions" .= conditions actspec,
+    "effects"    .= effects actspec
+    ]
+
+instance FromJSON ActSpec where
+  parseJSON = withObject "actspec" $ \o -> do
+    conditions <- o .: "conditions"
+    effects  <- o .: "effects"
+    return ActSpec{..}
+
+instance ToJSON Term where
+  toJSON (Not t)          = object ["term-type" .= JSON.String "Not",
+                                    "t" .= t]
+  toJSON (And t1 t2)      = object ["term-type" .= JSON.String "And",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Or t1 t2)       = object ["term-type" .= JSON.String "Or",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (BoolLit b)      = object ["term-type" .= JSON.String "BoolLit",
+                                    "b" .= b]
+
+  toJSON (Leq t1 t2)      = object ["term-type" .= JSON.String "Leq",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Geq t1 t2)      = object ["term-type" .= JSON.String "Geq",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Ge t1 t2)       = object ["term-type" .= JSON.String "Ge",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Le t1 t2)       = object ["term-type" .= JSON.String "Le",
+                                    "t1" .= t1, "t2" .= t2]
+
+  toJSON (Sub t1 t2)      = object ["term-type" .= JSON.String "Sub",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Add t1 t2)      = object ["term-type" .= JSON.String "Add",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Mult t1 t2)     = object ["term-type" .= JSON.String "Mult",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Mod t1 t2)      = object ["term-type" .= JSON.String "Mod",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Div t1 t2)      = object ["term-type" .= JSON.String "Div",
+                                    "t1" .= t1, "t2" .= t2]
+
+  toJSON (IntLit i)       = object ["term-type" .= JSON.String "IntLit",
+                                    "int" .= i]
+  toJSON (StringLit s)    = object ["term-type" .= JSON.String "StringLit",
+                                    "string" .= s]
+
+  toJSON (Eq t1 t2)       = object ["term-type" .= JSON.String "Eq",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Neq t1 t2)      = object ["term-type" .= JSON.String "Neq",
+                                    "t1" .= t1, "t2" .= t2]
+
+  toJSON (Exists vars t)  = object ["term-type" .= JSON.String "Exists",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (Forall vars t)  = object ["term-type" .= JSON.String "Forall",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (Count vars t)   = object ["term-type" .= JSON.String "Count",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (Sum vars t)     = object ["term-type" .= JSON.String "Sum",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (Max vars t)     = object ["term-type" .= JSON.String "Max",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (Min vars t)     = object ["term-type" .= JSON.String "Min",
+                                    "vars" .= vars,
+                                    "t" .= t]
+  toJSON (When t1 t2)     = object ["term-type" .= JSON.String "When",
+                                    "t1" .= t1, "t2" .= t2]
+  toJSON (Present t)      = object ["term-type" .= JSON.String "Present",
+                                    "t" .= t]
+  toJSON (Violated t)     = object ["term-type" .= JSON.String "Violated",
+                                    "t" .= t]
+  toJSON (Enabled t)      = object ["term-type" .= JSON.String "Enabled",
+                                    "t" .= t]
+  toJSON (Project t var)  = object ["term-type" .= JSON.String "Project",
+                                    "t" .= t, "var" .= var]
+
+  toJSON (Tag t domid)    = object ["term-type" .= JSON.String "Tag",
+                                    "t" .= t, "domID" .= domid]
+  toJSON (Untag t)        = object ["term-type" .= JSON.String "Untag",
+                                    "t" .= t]
+  toJSON (Ref var)        = object ["term-type" .= JSON.String "Ref",
+                                    "var" .= var]
+  toJSON (App domid args) = object ["term-type" .= JSON.String "App",
+                                    "domID" .= domid, "args"  .= args]
+  toJSON (CurrentTime)    = object ["term-type" .= JSON.String "CurrentTime"]
+
+instance FromJSON Term where
+  parseJSON = withObject "terms" $ \o -> do
+    termtype <- o .: "term-type"
+    case termtype of
+      "Not"           -> Not <$> o .: "t"
+      "And"           -> And <$> o .: "t1" <*> o .: "t2"
+      "Or"            -> Or <$> o .: "t1" <*> o .: "t2"
+      "BoolLit"       -> BoolLit <$> o .: "b"
+
+      "Leq"           -> Leq <$> o .: "t1" <*> o .: "t2"
+      "Geq"           -> Geq <$> o .: "t1" <*> o .: "t2"
+      "Ge"            -> Ge <$> o .: "t1" <*> o .: "t2"
+      "Le"            -> Le <$> o .: "t1" <*> o .: "t2"
+
+      "Sub"           -> Sub <$> o .: "t1" <*> o .: "t2"
+      "Add"           -> Add <$> o .: "t1" <*> o .: "t2"
+      "Mult"          -> Mult <$> o .: "t1" <*> o .: "t2"
+      "Mod"           -> Mod <$> o .: "t1" <*> o .: "t2"
+      "Div"           -> Div <$> o .: "t1" <*> o .: "t2"
+
+      "IntLit"        -> IntLit <$> o .: "int"
+      "StringLit"     -> StringLit <$> o .: "string"
+
+      "Eq"            -> Eq <$> o .: "t1" <*> o .: "t2"
+      "Neq"           -> Neq <$> o .: "t1" <*> o .: "t2"
+
+      "Exists"        -> Exists <$> o .: "vars" <*> o .: "t"
+      "Forall"        -> Forall <$> o .: "vars" <*> o .: "t"
+      "Count"         -> Count <$> o .: "vars" <*> o .: "t"
+      "Sum"           -> Sum <$> o .: "vars" <*> o .: "t"
+      "Max"           -> Max <$> o .: "vars" <*> o .: "t"
+      "Min"           -> Min <$> o .: "vars" <*> o .: "t"
+
+      "When"          -> When <$> o .: "t1" <*> o .: "t2"
+      "Present"       -> Present <$> o .: "t"
+      "Violated"      -> Violated <$> o .: "t"
+      "Enabled"       -> Enabled <$> o .: "t"
+      "Project"       -> Project <$> o .: "t" <*> o .: "var"
+
+      "Tag"           -> Tag <$> o .: "t" <*> o .: "domID"
+      "Untag"         -> Untag <$> o .: "t"
+      "Ref"           -> Ref <$> o .: "var"
+      "App"           -> App <$> o .: "domID" <*> o .: "args"
+      "CurrentTime"   -> return CurrentTime{}
+
+      _       -> fail ("unknown type: " ++ termtype)
+
+instance ToJSON Modifier where
+  toJSON (Rename var term) = object [
+    "var"  .= var,
+    "term" .= term
+    ]
+
+instance FromJSON Modifier where
+  parseJSON = withObject "modifier" $ \o -> do
+    var <- o.: "var"
+    term <- o.: "term"
+    return (Rename var term)
+
+
+instance ToJSON Effect where
+  toJSON (CAll vars t)  = object ["effect-type" .= JSON.String "CAll",
+                                     "vars" .= vars,
+                                     "term" .= t]
+  toJSON (TAll vars t)  = object ["effect-type" .= JSON.String "TAll",
+                                     "vars" .= vars,
+                                     "term" .= t]
+
+instance FromJSON Effect where
+  parseJSON = withObject "CAll or Tall" $ \o -> do
+    effecttype <- o .: "effect-type"
+    case effecttype of
+      "TAll"  -> TAll <$> o .: "vars" <*> o .: "term"
+      "CAll"  -> CAll <$> o .: "vars" <*> o .: "term"
+      _       -> fail ("unknown type: " ++ effecttype)
+
+instance ToJSON Var where
+  toJSON (Var domid string) = object [
+    "domID"  .= domid,
+    "string" .= string
+    ]
+
+instance FromJSON Var where
+  parseJSON = withObject "var" $ \o -> do
+    domid <- o.: "domID"
+    string <- o.: "string"
+    return (Var domid string)
+
+instance ToJSON DutySpec where
+  toJSON dutyspec = object [
+    "enforcing_acts" .= enforcing_acts dutyspec,
+    "violated_when"  .= violated_when dutyspec
+    ]
+
+instance FromJSON DutySpec where
+  parseJSON = withObject "dutyspec" $ \o -> do
+    enforcing_acts <- o.:? "enforcing_acts"
+    violated_when <- o.: "violated_when"
+    return DutySpec{..}
+
+instance ToJSON EventSpec where
+  toJSON eventspec = object [
+    "event_effects" .= event_effects eventspec
+    ]
+
+instance FromJSON EventSpec where
+  parseJSON = withObject "eventspec" $ \o -> do
+    event_effects <- o.: "event_effects"
+    return EventSpec{..}
+
+instance ToJSON Domain where
+  toJSON (AnyString)       = object ["domain-type" .= JSON.String "AnyString"]
+  toJSON (AnyInt)          = object ["domain-type" .= JSON.String "AnyInt"]
+  toJSON (Strings strings) = object ["domain-type" .= JSON.String "Strings", "strings" .= strings]
+  toJSON (Ints ints)       = object ["domain-type" .= JSON.String "Ints", "ints" .= ints]
+  toJSON (Products vars)   = object ["domain-type" .= JSON.String "Products", "vars" .= vars]
+  toJSON (Time)            = object ["domain-type" .= JSON.String "Time"]
+  toJSON (External)        = object ["domain-type" .= JSON.String "External"]
+
+instance FromJSON Domain where
+  parseJSON = withObject "anystring or anyint or strings or ints or products or time or external" $ \o -> do
+    domaintype <- o .: "domain-type"
+    case domaintype of
+      "AnyString" -> return AnyString{}
+      "AnyInt"    -> return AnyInt{}
+      "Strings"   -> Strings <$> o .: "strings"
+      "Ints"      -> Ints <$> o .: "ints"
+      "Products"  -> Products <$> o .: "vars"
+      "Time"      -> return Time{}
+      "External"  -> return External{}
+      _           -> fail ("unknown type: " ++ domaintype)
+
+instance ToJSON Derivation where
+  toJSON (Dv vars term)   = object ["derivation-type" .= JSON.String "Dv",
+                                    "vars" .= vars, "term" .= term]
+  toJSON (HoldsWhen term) = object ["derivation-type" .= JSON.String "HoldsWhen",
+                                    "term" .= term]
+  toJSON (ExternalValue)  = object ["derivation-type" .= JSON.String "ExternalValue"]
+
+instance FromJSON Derivation where
+  parseJSON = withObject "dv or holdswhen or externalvalue" $ \o -> do
+    derivationtype <- o .: "derivation-type"
+    case derivationtype of
+      "Dv"            -> Dv <$> o .: "vars" <*> o .: "term"
+      "HoldsWhen"     -> HoldsWhen <$> o .: "term"
+      "ExternalValue" -> return ExternalValue{}
+      _       -> fail ("unknown type: " ++ derivationtype)
+
+instance ToJSON Transition where
+  toJSON transition = object [
+    "tagged"  .= show (tagged transition),
+    "present" .= exist transition
+    ]
+
+instance FromJSON Transition where
+  parseJSON = withObject "transition" $ \o -> do
+    -- tagged <- o .: "tagged"
+    tagged_show <- o .: "tagged"
+    let tagged = read tagged_show
+    exist  <- o .: "present"
+    return Transition{tagged=tagged, exist=exist}
+
+-- Converting to/from graph
+instance ToJSON ExecutionGraph where
+  toJSON graph = object [
+    "current" .= current graph,
+    "nodes"   .=  nodes graph,
+    "edges"   .=  edges graph
+    ]
+
+instance FromJSON ExecutionGraph where
+  parseJSON = withObject "execution graph" $ \o -> do
+    current <- o .: "current"
+    nodes   <- o .: "nodes"
+    edges   <- o .: "edges"
+    return ExecutionGraph{..}
+
+instance ToJSON N where
+  toJSON node = object [
+    "ref"    .= ref node,
+    "config" .= config node
+    ]
+
+instance FromJSON N where
+  parseJSON = withObject "node" $ \o -> do
+    ref    <- o .: "ref"
+    config <- o .: "config"
+    return N{..}
+
+instance ToJSON Edge where
+  toJSON edge = object [
+    "source" .= source edge,
+    "target" .= target edge,
+    "po"     .= po edge
+    ]
+
+instance FromJSON Edge where
+  parseJSON = withObject "edge" $ \o -> do
+    source <- o .: "source"
+    target <- o .: "target"
+    po     <- o .: "po"
+    return Edge{..}
+
+instance ToJSON PO where
+  toJSON po = object [
+    -- "program" .= show (program po),
+    "program" .= ppPhrase (program po),
+    "output"  .= show (output po)
+    ]
+
+instance FromJSON PO where
+  parseJSON = withObject "program output" $ \o -> do
+    program_show <- o .: "program"
+    output_show  <- o .: "output"
+    -- let program =  read program_show
+    let output =  read output_show
+    -- return PO{program=program, output=output}
+    case parse_component syn_phrase program_show of
+      Left err  -> error(err)
+      Right ps  -> return PO{program=ps, output=output}
+
+-- NOTE
+-- Had to comment Spec.hs(Show Elem/Domain/Modifier/Var)) and print.hs(Show)
\ No newline at end of file
diff --git a/src/Sim.hs b/src/Sim.hs
index aa96fe4..4a07707 100644
--- a/src/Sim.hs
+++ b/src/Sim.hs
@@ -224,6 +224,12 @@ fire_act spec state act =
 
 -- ### instantiation mechanisms
 
+-- instance ToJSON State where
+--   toJSON state = object [
+--     "contents" .= contents state,
+--     "time"     .=  (time state)
+--     ]
+
 data TestResult = TestResult { 
                     success             :: Bool
                   , errors              :: [String]
@@ -233,7 +239,7 @@ data TestResult = TestResult {
                   , violated_invariants :: IM.IntMap [DomId]
                   , violated_duties     :: IM.IntMap [TaggedJSON]
                   , exec_actions        :: IM.IntMap (Maybe TransInfo)
-                  , reached_states      :: IM.IntMap State
+                  -- , reached_states      :: IM.IntMap State
                   , current_state       :: Int
                   } deriving (Generic) 
 
@@ -242,13 +248,13 @@ instance ToJSON TestResult where
 empty_test_result :: Spec -> State -> [TransInfo] -> [DutyInfo] -> [DomId] -> TestResult
 empty_test_result spec state powers duties breaches = 
   test_step' Nothing state powers duties breaches $
-  TestResult True [] [] IM.empty IM.empty IM.empty IM.empty IM.empty IM.empty (-1)
+  TestResult True [] [] IM.empty IM.empty IM.empty IM.empty IM.empty (-1)
 
 test_step :: TransInfo -> State -> [TransInfo] -> [DutyInfo] -> [DomId] -> TestResult -> TestResult 
 test_step a = test_step' (Just a)
 test_step' maction state powers duties breaches tr = 
   tr { exec_actions   = (if isNothing maction then id else IM.insert k maction) (exec_actions tr)
-     , reached_states = IM.insert k state (reached_states tr)
+     -- , reached_states = IM.insert k state (reached_states tr)
      , present_powers = IM.insert k (map (TaggedJSON . trans_tagged) powers) (present_powers tr)
      , present_duties = IM.insert k (map duty_res duties) (present_duties tr)
      , violated_duties = IM.insert k (map TaggedJSON viol_duties) (violated_duties tr)
@@ -267,7 +273,7 @@ test_step' maction state powers duties breaches tr =
 test_repeat_step :: TestResult -> TestResult
 test_repeat_step tr = 
   tr { exec_actions = IM.insert k Nothing (exec_actions tr)
-     , reached_states = IM.insert k (reached_states tr IM.! (k-1)) (reached_states tr)
+     -- , reached_states = IM.insert k (reached_states tr IM.! (k-1)) (reached_states tr)
      , present_powers = IM.insert k (present_powers tr IM.! (k-1)) (present_powers tr)
      , present_duties = IM.insert k (present_duties tr IM.! (k-1)) (present_duties tr)
      , violated_duties = IM.insert k (violated_duties tr IM.! (k-1)) (violated_duties tr)
diff --git a/src/Spec.hs b/src/Spec.hs
index ab876c1..d69a261 100644
--- a/src/Spec.hs
+++ b/src/Spec.hs
@@ -9,17 +9,18 @@ import qualified Data.Map as M
 import qualified Data.Set as S
 
 import Data.Aeson hiding (String)
+import qualified Data.Aeson as JSON
 
 type DomId      = String -- type identifiers
 type Tagged     = (Elem, DomId)
 
 data Var        = Var DomId String {- decoration -}
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data Elem       = String String 
                 | Int Int
                 | Product [Tagged]
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data Domain     = AnyString
                 | AnyInt
@@ -28,7 +29,7 @@ data Domain     = AnyString
                 | Products [Var]
                 | Time
                 | External
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 isExternal :: Spec -> Var -> Bool 
 isExternal spec x = case find_decl spec (remove_decoration spec x) of
@@ -55,53 +56,49 @@ enumerable spec d = case d of
 type Arguments  = Either [Term] [Modifier]
 
 data Modifier   = Rename Var Term -- with var instantiated instead as the value of expr
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data Kind       = Fact FactSpec | Act ActSpec | Duty DutySpec | Event EventSpec
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data TypeSpec   = TypeSpec {
                       kind  :: Kind
                     , domain :: Domain
                     , domain_constraint :: Term
                     , derivation :: Maybe [Derivation]
-                    } deriving (Eq)
+                    } deriving (Eq, Show, Read)
 
 data Derivation = Dv [Var] Term
                 | HoldsWhen Term
                 | ExternalValue
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data FactSpec   = FactSpec {
                       invariant :: Bool -- TODO move to outer AST
                     , actor     :: Bool
                     }
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data DutySpec   = DutySpec {
                       enforcing_acts :: Maybe [DomId] --TODO move to outer ast
                     , violated_when  :: [Term] 
                     }
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data ActSpec    = ActSpec {
                       conditions  :: [Term]
-                    , effects     :: [Effect]
-                    , syncs       :: [Sync] 
+                    , effects     :: [Effect] 
                     }
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data Effect     = CAll  [Var] Term
                 | TAll  [Var] Term
-                deriving (Ord, Eq)
-
-data Sync       = Sync [Var] Term
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data EventSpec  = EventSpec { 
                       event_effects :: [Effect] 
                     }
-                deriving (Ord, Eq)
+                deriving (Ord, Eq, Show, Read)
 
 data Spec       = Spec {
                     decls       :: M.Map DomId TypeSpec
@@ -109,7 +106,7 @@ data Spec       = Spec {
                   , invariants  :: S.Set DomId
                   , actors      :: S.Set DomId
                   }
-                deriving (Eq)
+                deriving (Eq, Show, Read)
 
 -- | Union of specifications with overrides/replacements, not concretizations
 spec_union :: Spec -> Spec -> Spec
@@ -182,40 +179,39 @@ data Phrase = PDo Bool Tagged
             | Reconfigure [Effect]
             | PFrames Spec [TypeExt]
             | PSkip
-            deriving (Eq)
+            deriving (Eq, Show, Read)
 
 data TypeDecl = FactTypeDecl Bool DomId Domain Term (Maybe [Derivation]) 
               | PredTypeDecl DomId Term  -- compiles away to FactTypeDecl
               | InvTypeDecl  DomId Term  -- compiles away to PredTypeDecl + invariant directive 
               | DutyTypeDecl DomId Domain Term (Maybe [Derivation]) [Term] (Maybe [DomId])
-              | ActTypeDecl  DomId Domain Term (Maybe [Derivation]) [Term] [Effect] [Sync] 
+              | ActTypeDecl  DomId Domain Term (Maybe [Derivation]) [Term] [Effect] 
               | EventTypeDecl  DomId Domain Term [Derivation] [Effect]
-              deriving (Eq) 
+              deriving (Eq, Show, Read) 
 
 id_of :: TypeDecl -> DomId
 id_of (FactTypeDecl _ d _ _ _) = d
 id_of (PredTypeDecl d _) = d
 id_of (InvTypeDecl d _) = d
 id_of (DutyTypeDecl d _ _ _ _ _) = d
-id_of (ActTypeDecl d _ _ _ _ _ _) = d
+id_of (ActTypeDecl d _ _ _ _ _) = d
 id_of (EventTypeDecl d _ _ _ _) = d
 
-data TypeExt  = ActExt DomId [Term] (Maybe [Derivation]) [Effect] [Sync] -- TODO fix treatment of derivation clauses (in both semantics)
+data TypeExt  = ActExt DomId [Term] (Maybe [Derivation]) [Effect] -- TODO fix treatment of derivation clauses (in both semantics)
               | EventExt DomId (Maybe [Derivation]) [Effect]
               | DutyExt DomId (Maybe [Derivation]) [Term]
               | FactExt DomId [Derivation]
-              deriving (Eq)
+              deriving (Eq, Show, Read)
 
 -- before compilation
 apply_ext :: TypeExt -> Spec -> Spec
 apply_ext ext spec = case find_decl spec (id_of_ext ext) of
   Nothing    -> spec
   Just tspec -> case (kind tspec, ext) of 
-    (Act aspec, ActExt ty pres mdvs efs ss) -> spec { decls = M.insert ty tspec' (decls spec) }
+    (Act aspec, ActExt ty pres mdvs efs) -> spec { decls = M.insert ty tspec' (decls spec) }
       where tspec' = tspec { kind = kind', derivation = maybe mdvs (\old -> Just $ maybe old (old++) mdvs) (derivation tspec) }
             kind'  = Act $ aspec { conditions = conditions aspec ++ pres
-                                 , effects = effects aspec ++ efs
-                                 , syncs = syncs aspec ++ ss }
+                                 , effects = effects aspec ++ efs }
     (Duty dspec, DutyExt ty mdvs viols) -> spec { decls = M.insert ty tspec' (decls spec) }
       where tspec' = tspec { kind = kind', derivation = maybe mdvs (\old -> Just $ maybe old (old++) mdvs) (derivation tspec) }
             kind'  = Duty $ dspec { violated_when = violated_when dspec ++ viols }
@@ -227,7 +223,7 @@ apply_ext ext spec = case find_decl spec (id_of_ext ext) of
     _ -> spec
 
 id_of_ext :: TypeExt -> DomId
-id_of_ext (ActExt d _ _ _ _) = d
+id_of_ext (ActExt d _ _ _) = d
 id_of_ext (EventExt d _ _) = d
 id_of_ext (DutyExt d _ _) = d
 id_of_ext (FactExt d _) = d
@@ -289,7 +285,7 @@ data Term       = Not Term
                 | Ref Var
                 | App DomId Arguments 
                 | CurrentTime
-                deriving (Show, Ord, Eq)
+                deriving (Show, Ord, Eq, Read)
 
 data Value      = ResBool Bool
                 | ResString String
@@ -308,27 +304,27 @@ instance Show TransType where
   show AddEvent = "+"
   show RemEvent = "-"
 
-instance Show Elem where
-  show v = case v of
-    String s    -> show s
-    Int i       -> show i
-    Product cs  -> "(" ++ intercalate "," (map show_component cs) ++ ")"
+-- instance Show Elem where
+--   show v = case v of
+--     String s    -> show s
+--     Int i       -> show i
+--     Product cs  -> "(" ++ intercalate "," (map show_component cs) ++ ")"
 
-instance Show Domain where
-  show r = case r of
-    External      -> "<External>"
-    Time          -> "<TIME>"
-    AnyString     -> "<STRING>" 
-    Strings ss    -> "<STRING:" ++ intercalate "," (map show ss) ++ ">"
-    AnyInt        -> "<INT>"
-    Ints is       -> "<INT:" ++ intercalate "," (map show is) ++ ">"
-    Products rs   -> "(" ++ intercalate " * " (map show rs) ++ ")"
+-- instance Show Domain where
+--   show r = case r of
+--     External      -> "<External>"
+--     Time          -> "<TIME>"
+--     AnyString     -> "<STRING>" 
+--     Strings ss    -> "<STRING:" ++ intercalate "," (map show ss) ++ ">"
+--     AnyInt        -> "<INT>"
+--     Ints is       -> "<INT:" ++ intercalate "," (map show is) ++ ">"
+--     Products rs   -> "(" ++ intercalate " * " (map show rs) ++ ")"
 
-instance Show Modifier where
-  show (Rename dt1 dt2) = show dt1 ++ " = " ++ show dt2
+-- instance Show Modifier where
+--   show (Rename dt1 dt2) = show dt1 ++ " = " ++ show dt2
 
-instance Show Var where
-  show (Var ty dec) = ty ++ dec
+-- instance Show Var where
+--   show (Var ty dec) = ty ++ dec
 
 no_decoration :: DomId -> Var
 no_decoration ty = Var ty "" 
@@ -478,8 +474,6 @@ newtype TaggedJSON = TaggedJSON Tagged
 
 instance ToJSON TaggedJSON where
   toJSON (TaggedJSON te@(v,d)) = case v of 
-    String s    -> object [ "fact-type" .= toJSON d, "value" .= toJSON s, "textual" .= toJSON (ppTagged te) ]
-    Int i       -> object [ "fact-type" .= toJSON d, "value" .= toJSON i, "textual" .= toJSON (ppTagged te)  ]
-    Product tes -> object [ "fact-type" .= toJSON d, "arguments" .= toJSON (map TaggedJSON tes), "textual" .= toJSON (ppTagged te) ]
-
-
+    String s    -> object [ "tagged-type" .= JSON.String "string", "fact-type" .= toJSON d, "value" .= toJSON s, "textual" .= toJSON (ppTagged te) ]
+    Int i       -> object [ "tagged-type" .= JSON.String "int", "fact-type" .= toJSON d, "value" .= toJSON i, "textual" .= toJSON (ppTagged te)  ]
+    Product tes -> object [ "tagged-type" .= JSON.String "product", "fact-type" .= toJSON d, "arguments" .= toJSON (map TaggedJSON tes), "textual" .= toJSON (ppTagged te) ]
diff --git a/src/State.hs b/src/State.hs
index 3c55851..54f355b 100644
--- a/src/State.hs
+++ b/src/State.hs
@@ -10,7 +10,7 @@ import Control.Applicative (empty)
 
 data Meta   = Meta {
               }
-              deriving Eq
+              deriving (Eq, Read, Show)
 
 data State =  State {
                   contents :: M.Map Tagged Meta  -- meta-info about components
@@ -18,6 +18,12 @@ data State =  State {
               }
               deriving Eq
 
+data Transition = Transition {
+                    tagged :: Tagged
+                  , exist :: Bool
+                  }  
+                  deriving (Ord, Eq, Show, Read)
+
 create :: Tagged -> State -> State
 create te s = s { contents = M.insert te Meta{} (contents s) }
 
@@ -43,8 +49,8 @@ instance Show State where
       | (c,m) <- M.assocs (contents state)
       ]
 
-instance ToJSON State where
- toJSON state = toJSON (map TaggedJSON (state_holds state)) 
+-- instance ToJSON State where
+ -- toJSON state = toJSON (map TaggedJSON (state_holds state)) 
 
 state_holds :: State -> [Tagged]
 state_holds state = [ te | (te, m) <- M.assocs (contents state) ]
@@ -52,7 +58,7 @@ state_holds state = [ te | (te, m) <- M.assocs (contents state) ]
 data Context = Context {
                   ctx_spec        :: Spec --mutable 
                 , ctx_state       :: State --mutable 
-                , ctx_transitions :: [(Tagged, Bool)] -- (label * enabled?) -- replaceable
+                , ctx_transitions :: [Transition] -- (label * enabled?) -- replaceable
                 , ctx_duties      :: [Tagged] -- replaceable
                 }
 
@@ -70,18 +76,18 @@ emptyContext spec =
 data Violation = DutyViolation      Tagged
                | TriggerViolation   Tagged Bool {- whether action? (or event) -}
                | InvariantViolation DomId
-               deriving (Ord, Eq) 
+               deriving (Ord, Eq, Show, Read) 
 
 data OutputEvent = ExecutedTransition Tagged Bool {- action or event? -}
-                 deriving (Ord, Eq)
+                 deriving (Ord, Eq, Show, Read)
 
 data QueryRes = QuerySuccess
               | QueryFailure
-              deriving (Ord, Eq)
+              deriving (Ord, Eq, Show, Read)
 
 data Error = -- trigger errors
              DisabledTransition Tagged
            | NonDeterministicTransition
            | CompilationError String
-           deriving (Eq,Ord) 
+           deriving (Eq, Ord, Show, Read) 
 
diff --git a/src/StaticEval.hs b/src/StaticEval.hs
index 88653a7..a28021c 100644
--- a/src/StaticEval.hs
+++ b/src/StaticEval.hs
@@ -119,8 +119,8 @@ compile_phrase p ctx = case p of
       compile_type_spec ctx ty dom domf mdv (Fact (FactSpec False {- Boolean will be ignored -} is_actor))
     DutyTypeDecl ty dom domf mdv mvt mefs -> 
       compile_type_spec ctx ty dom domf mdv (Duty (DutySpec {violated_when = mvt, enforcing_acts = mefs}))
-    ActTypeDecl ty dom domf mdv precons postcons ss -> 
-      compile_type_spec ctx ty dom domf mdv (Act (ActSpec { conditions = precons, effects = postcons, syncs = ss }))
+    ActTypeDecl ty dom domf mdv precons postcons -> 
+      compile_type_spec ctx ty dom domf mdv (Act (ActSpec { conditions = precons, effects = postcons }))
     EventTypeDecl ty dom domf dv postcons -> 
       compile_type_spec ctx ty dom domf (Just dv) (Event (EventSpec { event_effects = postcons }))
   PExt ext -> compile_ext ctx ext
@@ -144,14 +144,13 @@ compile_ext ctx ext = case M.lookup ty (decls (ctx_spec ctx)) of
  Just tspec -> do
   let Products xs = domain tspec
   case (kind tspec, ext) of
-   (Act _, ActExt ty pres mdv postcons ss) -> flip runStatic (ctx_spec ctx) $ do
-     syncs' <- mapM (compile_sync xs) ss
+   (Act _, ActExt ty pres mdv postcons) -> flip runStatic (ctx_spec ctx) $ do 
      effects' <- sequence (map (compile_effect xs) postcons)
      derivation' <- (case mdv of Nothing      -> return Nothing 
                                  Just []      -> return Nothing
                                  Just dvs     -> Just <$> mapM (compile_derivation xs ty) dvs)
      pres' <- mapM (convert_precon tspec) pres
-     return $ CExt (ActExt ty pres' derivation' effects' syncs')
+     return $ CExt (ActExt ty pres' derivation' effects')
    (Event _, EventExt ty mdv postcons) -> flip runStatic (ctx_spec ctx) $ do 
      effects' <- sequence (map (compile_effect xs) postcons)
      derivation' <- (case mdv of Nothing      -> return Nothing 
@@ -204,10 +203,8 @@ compile_kind ty tspec k = case k of
     conds' <- mapM (convert_precon tspec) (conditions aspec)
     -- convert post-conditions
     effects' <- sequence (map (compile_effect xs) (effects aspec))
-    -- convert syncs
-    syncs' <- mapM (compile_sync xs) (syncs aspec)
     -- build new act
-    return (Act (aspec { conditions = conds', effects = effects', syncs = syncs' } ))
+    return (Act (aspec { conditions = conds', effects = effects' } ))
   Event espec -> do 
     let Products xs = domain tspec
     effects' <- sequence (map (compile_effect xs) (event_effects espec))
@@ -238,14 +235,6 @@ compile_violation_condition dty term = do
              | otherwise     = Exists unbounds term'
   return term'' 
 
-compile_sync :: [Var] -> Sync -> M_Stc Sync 
-compile_sync bound (Sync vars t) = do
-  (t', tau) <- compile_term t
-  case tau of
-    TyTagged _ -> do  frees <- free_vars t'
-                      let unbounds = S.toList (frees `S.difference` S.fromList (vars ++ bound))
-                      return $ Sync (vars ++ unbounds) t' 
-    _          -> err ("sync clause is not an instance expression")
 
 compile_spec :: M_Stc Spec
 compile_spec = get_spec >>= compile_spec'
